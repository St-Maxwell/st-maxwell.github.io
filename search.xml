<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>电子积分库Libcint的用法</title>
    <url>/use-libcint/</url>
    <content><![CDATA[<p><a href="https://github.com/sunqm/libcint" target="_blank" rel="noopener">libcint</a>是Sun Qiming写的电子积分库，有Fortran接口。我想以后使用它写点小玩意。现在先尝试搞懂它的用法，并分享自己的一点经验。</p>
<p>当然最重要的是看libcint自己的手册（和GitHub仓库里的例子），然后可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/AULtH_7iPnaA8g5y46T_HQ" target="_blank" rel="noopener">Libcint电子积分库使用教程</a><br><a id="more"></a><br>计算积分前要先将每一个primitive Gaussian函数（直接从基组文件里读取的）归一化，然后将重叠矩阵的对角元归一化。</p>
<p>调用<code>CINTgto_norm</code>函数，它接受primitive Gaussian函数的总角动量<code>angl</code>（笛卡尔型Gaussian函数的总角动量$l=l_x+l_y+l_z$）和指数项<code>expnt</code>（$\alpha$）。乘到primitive Gaussian函数对应的收缩系数<code>cntr_coeff</code>即可。<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">cntr_coeff = cntr_coeff * CINTgto_norm(angl, expnt)</span><br></pre></td></tr></table></figure></p>
<p>我写了一个简单的测试（比较随意，有些地方是写死的），计算了水分子的def2-SVP基组的电子积分。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mod_info</span><br><span class="line">    <span class="keyword">use</span> <span class="keyword">iso_fortran_env</span>, <span class="keyword">only</span>: r8 =&gt; real64</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">! molecule: water</span></span><br><span class="line">    <span class="comment">! basis set: def2-SVP</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: natm = <span class="number">3</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: nshl = <span class="number">12</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: nprm = <span class="number">22</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: nbas = <span class="number">24</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(nshl), <span class="keyword">parameter</span> :: cntr_odr = &amp;</span><br><span class="line">    [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(nshl), <span class="keyword">parameter</span> :: angl = &amp;</span><br><span class="line">    [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(nshl), <span class="keyword">parameter</span> :: shl_belong_to_atom = &amp;</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(nshl), <span class="keyword">parameter</span> :: sh_indx = &amp;</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nprm), <span class="keyword">parameter</span> :: expnt = &amp;</span><br><span class="line">    [ <span class="number">2266.1767785</span>, <span class="number">340.87010191</span>, <span class="number">77.363135167</span>, &amp;</span><br><span class="line">      <span class="number">21.479644940</span>, <span class="number">6.6589433124</span>, <span class="number">0.80975975668</span>, &amp;</span><br><span class="line">      <span class="number">0.25530772234</span>, <span class="number">17.721504317</span>, <span class="number">3.8635505440</span>, &amp;</span><br><span class="line">      <span class="number">1.0480920883</span>, <span class="number">0.27641544411</span>, <span class="number">1.2000000</span>, &amp;</span><br><span class="line">      <span class="number">13.0107010</span>, <span class="number">1.9622572</span>, <span class="number">0.44453796</span>, &amp;</span><br><span class="line">      <span class="number">0.12194962</span>, <span class="number">0.8000000</span>, <span class="number">13.0107010</span>, &amp;</span><br><span class="line">      <span class="number">1.9622572</span>, <span class="number">0.44453796</span>, <span class="number">0.12194962</span>, &amp;</span><br><span class="line">      <span class="number">0.8000000</span> ]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nprm), <span class="keyword">parameter</span> :: coeff = &amp;</span><br><span class="line">    [ -<span class="number">0.53431809926E-02</span>, -<span class="number">0.39890039230E-01</span>, -<span class="number">0.17853911985</span>, &amp;</span><br><span class="line">      -<span class="number">0.46427684959</span>, -<span class="number">0.44309745172</span>, <span class="number">1.0000000</span>, &amp;</span><br><span class="line">      <span class="number">1.0000000</span>, <span class="number">0.43394573193E-01</span>, <span class="number">0.23094120765</span>, &amp;</span><br><span class="line">      <span class="number">0.51375311064</span>, <span class="number">1.0000000</span>, <span class="number">1.0000000</span>, &amp;</span><br><span class="line">      <span class="number">0.19682158E-01</span>, <span class="number">0.13796524</span>, <span class="number">0.47831935</span>, &amp;</span><br><span class="line">      <span class="number">1.0000000</span>, <span class="number">1.0000000</span>, <span class="number">0.19682158E-01</span>, &amp;</span><br><span class="line">      <span class="number">0.13796524</span>, <span class="number">0.47831935</span>, <span class="number">1.0000000</span>, &amp;</span><br><span class="line">      <span class="number">1.0000000</span> ]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(<span class="number">3</span>,natm), <span class="keyword">parameter</span> :: geom = <span class="built_in">reshape</span>(&amp;</span><br><span class="line">    [ <span class="number">0.00000000</span>, -<span class="number">0.00000000</span>, -<span class="number">0.11085125</span>, &amp;</span><br><span class="line">      <span class="number">0.00000000</span>, -<span class="number">0.78383672</span>, <span class="number">0.44340501</span>, &amp;</span><br><span class="line">      <span class="number">0.00000000</span>, <span class="number">0.78383672</span>, <span class="number">0.44340501</span> ], [<span class="number">3</span>,natm])</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(natm), <span class="keyword">parameter</span> :: charge = [<span class="number">8</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span> mod_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mod_libcint</span><br><span class="line">    <span class="keyword">use</span> mod_info</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(:,:), <span class="keyword">allocatable</span> :: atm</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(:,:), <span class="keyword">allocatable</span> :: bas</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(:), <span class="keyword">allocatable</span> :: env</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: CHARGE_OF  = <span class="number">1</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: PTR_COORD  = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: NUC_MOD_OF = <span class="number">3</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: PTR_ZETA   = <span class="number">4</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: ATM_SLOTS  = <span class="number">6</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: ATOM_OF    = <span class="number">1</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: ANG_OF     = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: NPRIM_OF   = <span class="number">3</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: NCTR_OF    = <span class="number">4</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: KAPPA_OF   = <span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: PTR_EXP    = <span class="number">6</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: PTR_COEFF  = <span class="number">7</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: BAS_SLOTS  = <span class="number">8</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: PTR_ENV_START = <span class="number">20</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> set_libcint_input()</span><br><span class="line">        <span class="keyword">integer</span> :: off, prim_off</span><br><span class="line">        <span class="keyword">integer</span> :: iatom, ishl, iprim, ioff</span><br><span class="line">        <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">external</span> :: CINTgto_norm</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">allocate</span>(atm(ATM_SLOTS,natm))</span><br><span class="line">        <span class="built_in">allocate</span>(bas(BAS_SLOTS,nshl))</span><br><span class="line">        <span class="built_in">allocate</span>(env(PTR_ENV_START+<span class="number">3</span>*natm+<span class="number">2</span>*nprm))</span><br><span class="line">  </span><br><span class="line">        off = PTR_ENV_START</span><br><span class="line">        <span class="keyword">do</span> iatom = <span class="number">1</span>, natm</span><br><span class="line">            atm(CHARGE_OF,iatom) = charge(iatom)</span><br><span class="line">            atm(PTR_COORD,iatom) = off</span><br><span class="line">            atm(NUC_MOD_OF,iatom) = <span class="number">1</span></span><br><span class="line">            env(off+<span class="number">1</span>:) = geom(:,iatom)</span><br><span class="line">            off = off + <span class="number">3</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">        prim_off = <span class="number">1</span></span><br><span class="line">        <span class="keyword">do</span> ishl = <span class="number">1</span>, nshl</span><br><span class="line">            bas(ATOM_OF,ishl) = shl_belong_to_atom(ishl) - <span class="number">1</span></span><br><span class="line">            bas(ANG_OF,ishl) = angl(ishl)</span><br><span class="line">            bas(NPRIM_OF,ishl) = cntr_odr(ishl)</span><br><span class="line">            bas(NCTR_OF,ishl) = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">            bas(PTR_EXP,ishl) = off</span><br><span class="line">            ioff = <span class="number">0</span></span><br><span class="line">            <span class="keyword">do</span> iprim = prim_off, prim_off + cntr_odr(ishl)-<span class="number">1</span></span><br><span class="line">                env(off+<span class="number">1</span>+ioff) = expnt(iprim)</span><br><span class="line">                ioff = ioff + <span class="number">1</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">            off = off + cntr_odr(ishl)</span><br><span class="line">  </span><br><span class="line">            bas(PTR_COEFF,ishl) = off</span><br><span class="line">            ioff = <span class="number">0</span></span><br><span class="line">            <span class="keyword">do</span> iprim = prim_off, prim_off + cntr_odr(ishl)-<span class="number">1</span></span><br><span class="line">                env(off+<span class="number">1</span>+ioff) = coeff(iprim) * CINTgto_norm(angl(ishl), expnt(iprim))</span><br><span class="line">                ioff = ioff + <span class="number">1</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">            off = off + cntr_odr(ishl)</span><br><span class="line">  </span><br><span class="line">            prim_off = prim_off + cntr_odr(ishl)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> set_libcint_input</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> normalize()</span><br><span class="line">        <span class="keyword">integer</span> :: ishl, iprim</span><br><span class="line">        <span class="keyword">integer</span> :: di, dj</span><br><span class="line">        <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(:,:), <span class="keyword">allocatable</span> :: buf1e</span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">dimension</span>(<span class="number">2</span>) :: shls</span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">external</span> :: CINTcgto_spheric</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">do</span> ishl = <span class="number">1</span>, nshl</span><br><span class="line">            shls(<span class="number">1</span>) = ishl - <span class="number">1</span></span><br><span class="line">            shls(<span class="number">2</span>) = ishl - <span class="number">1</span></span><br><span class="line">            di = CINTcgto_spheric(ishl-<span class="number">1</span>, bas)</span><br><span class="line">            dj = CINTcgto_spheric(ishl-<span class="number">1</span>, bas)</span><br><span class="line">            <span class="built_in">allocate</span>(buf1e(di,dj))</span><br><span class="line">            <span class="keyword">call</span> cint1e_ovlp_sph(buf1e,shls,atm,natm,bas,nshl,env)</span><br><span class="line">            <span class="keyword">do</span> iprim = <span class="number">1</span>, cntr_odr(ishl)</span><br><span class="line">                env(bas(PTR_COEFF,ishl)+iprim) = env(bas(PTR_COEFF,ishl)+iprim) / <span class="built_in">sqrt</span>(buf1e(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">deallocate</span>(buf1e)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> normalize</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span> mod_libcint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> mod_info</span><br><span class="line">    <span class="keyword">use</span> mod_libcint</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: i, j, k, l, di, dj, dk, dl, x, y, z, w</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nbas,nbas) :: S</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nbas,nbas) :: T</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nbas,nbas) :: V</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nbas,nbas,nbas,nbas) :: eri</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(:,:), <span class="keyword">allocatable</span> :: buf1e</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(:,:,:,:), <span class="keyword">allocatable</span> :: buf2e</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(<span class="number">4</span>) :: shls</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: CINTcgto_spheric</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">call</span> set_libcint_input()</span><br><span class="line">    <span class="keyword">call</span> normalize()</span><br><span class="line">  </span><br><span class="line">    open(<span class="number">11</span>, <span class="keyword">file</span>=<span class="string">"int.txt"</span>)</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*) atm(CHARGE_OF,:) </span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*) atm(PTR_COORD,:) </span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*) atm(NUC_MOD_OF,:)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nshl</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">11</span>,<span class="string">"(*(I4))"</span>) bas(ATOM_OF,i), bas(ANG_OF,i), bas(NPRIM_OF,i), &amp;</span><br><span class="line">                            bas(NCTR_OF,i), bas(PTR_EXP,i), bas(PTR_COEFF,i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, <span class="built_in">size</span>(env)</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">11</span>,*) i, env(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nshl</span><br><span class="line">        shls(<span class="number">1</span>) = i - <span class="number">1</span></span><br><span class="line">        di = CINTcgto_spheric(i-<span class="number">1</span>, bas)</span><br><span class="line">        <span class="keyword">do</span> j = <span class="number">1</span>, nshl</span><br><span class="line">            shls(<span class="number">2</span>) = j - <span class="number">1</span></span><br><span class="line">            dj = CINTcgto_spheric(j-<span class="number">1</span>, bas)</span><br><span class="line">            <span class="built_in">allocate</span>(buf1e(di,dj))</span><br><span class="line">            x = sh_indx(i); y = sh_indx(j)</span><br><span class="line">            <span class="keyword">call</span> cint1e_ovlp_sph(buf1e,shls,atm,natm,bas,nshl,env)</span><br><span class="line">            S(x:,y:) = buf1e(:,:)</span><br><span class="line">            <span class="keyword">call</span> cint1e_kin_sph(buf1e,shls,atm,natm,bas,nshl,env)</span><br><span class="line">            T(x:,y:) = buf1e(:,:)</span><br><span class="line">            <span class="keyword">call</span> cint1e_nuc_sph(buf1e,shls,atm,natm,bas,nshl,env)</span><br><span class="line">            V(x:,y:) = buf1e(:,:)</span><br><span class="line">            <span class="built_in">deallocate</span>(buf1e)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nshl</span><br><span class="line">      shls(<span class="number">1</span>) = i - <span class="number">1</span></span><br><span class="line">      di = CINTcgto_spheric(i-<span class="number">1</span>, bas)</span><br><span class="line">      <span class="keyword">do</span> j = <span class="number">1</span>, nshl</span><br><span class="line">          shls(<span class="number">2</span>) = j - <span class="number">1</span></span><br><span class="line">          dj = CINTcgto_spheric(j-<span class="number">1</span>, bas)</span><br><span class="line">          <span class="keyword">do</span> k = <span class="number">1</span>, nshl</span><br><span class="line">              shls(<span class="number">3</span>) = k - <span class="number">1</span></span><br><span class="line">              dk = CINTcgto_spheric(k-<span class="number">1</span>, bas)</span><br><span class="line">              <span class="keyword">do</span> l = <span class="number">1</span>, nshl</span><br><span class="line">                  shls(<span class="number">4</span>) = l - <span class="number">1</span></span><br><span class="line">                  dl = CINTcgto_spheric(l-<span class="number">1</span>, bas)</span><br><span class="line">                  <span class="built_in">allocate</span>(buf2e(di,dj,dk,dl))</span><br><span class="line">                  x = sh_indx(i); y = sh_indx(j)</span><br><span class="line">                  z = sh_indx(k); w = sh_indx(l)</span><br><span class="line">                  <span class="keyword">call</span> cint2e_sph(buf2e,shls,atm,natm,bas,nshl,env,<span class="number">0</span>_8)</span><br><span class="line">                  eri(x:,y:,z:,w:) = buf2e(:,:,:,:)</span><br><span class="line">                  <span class="built_in">deallocate</span>(buf2e)</span><br><span class="line">              <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">          <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nbas</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">11</span>,<span class="string">"(*(F15.10))"</span>) S(i,:)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*)</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nbas</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">11</span>,<span class="string">"(*(F15.10))"</span>) T(i,:)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*)</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nbas</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">11</span>,<span class="string">"(*(F15.10))"</span>) V(i,:)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*)</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nbas</span><br><span class="line">        <span class="keyword">do</span> j = <span class="number">1</span>, nbas</span><br><span class="line">            <span class="keyword">do</span> k = <span class="number">1</span>, nbas</span><br><span class="line">                <span class="built_in">write</span>(<span class="number">11</span>,<span class="string">"(*(F15.10))"</span>) eri(i,j,k,:)</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(<span class="number">11</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> main</span><br></pre></td></tr></table></figure>
<p>我们可以用Psi4的电子积分做对比。有些矩阵元的顺序不一样，这个很正常（2p壳层的3个基函数的顺序不同）。</p>
<p>Psi4获得电子积分的代码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> psi4</span><br><span class="line"></span><br><span class="line">mol = psi4.geometry(<span class="string">'''</span></span><br><span class="line"><span class="string">    O  0.00000000  -0.00000000 -0.11085125</span></span><br><span class="line"><span class="string">    H  0.00000000  -0.78383672  0.44340501</span></span><br><span class="line"><span class="string">    H  0.00000000   0.78383672  0.44340501</span></span><br><span class="line"><span class="string">    unit = au</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line">basis_set = <span class="string">"def2-SVP"</span></span><br><span class="line"></span><br><span class="line">wfn = psi4.core.Wavefunction.build(mol, basis_set)</span><br><span class="line">mints = psi4.core.MintsHelper(wfn.basisset())</span><br><span class="line"></span><br><span class="line"><span class="comment"># get integrals from psi4 module</span></span><br><span class="line">Enuc = mol.nuclear_repulsion_energy()</span><br><span class="line">S = np.asarray(mints.ao_overlap())</span><br><span class="line">V = np.asarray(mints.ao_potential())</span><br><span class="line">T = np.asarray(mints.ao_kinetic())</span><br><span class="line">I = np.asarray(mints.ao_eri())</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>量化编程</tag>
        <tag>Libcint</tag>
      </tags>
  </entry>
  <entry>
    <title>Ringo——我的第一个量化程序</title>
    <url>/ringo/</url>
    <content><![CDATA[<p>目前 <cite lang="en">Modern Quantum Chemistry</cite> 上氢分子和氦氢离子（HeH<sup>+</sup>）的两个例子已经学完了。</p>
<p>然后我就尝试写出了自己的第一个量化程序，用于 HeH<sup>+</sup> 的 RHF/STO-3G 的计算。</p>
<p>程序是用 Fortran 写的。<br><a id="more"></a><br>代码和文档上传到了Github：<a href="https://github.com/St-Maxwell/Ringo" target="_blank" rel="noopener">https://github.com/St-Maxwell/Ringo</a></p>
<p>因为基本上所有内容都在文档中，所以这里不再详细介绍了。</p>
<p>如果有人对量化编程有兴趣，希望我的代码和文档能帮助到你。</p>
<p>随着我未来对理论化学的学习，会逐渐为这个代码的增加更多的内容。</p>
<p>运行结果<br><img src="../images/2017-11-30-1.png" alt=""></p>
<p>与Gaussian的结果的对比<br><img src="../images/2017-11-30-2.png" alt=""></p>
<p><hr /><br>Update(2020/2/10): 现在使用了Libcint库计算电子积分，因此原来的代码已全部重写。现有的版本支持更多基组（主要是def2系列和相关一致基组），以及简单的输入文件解析。今后将以此为基础进行开发。</p>
]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>量化编程</tag>
      </tags>
  </entry>
  <entry>
    <title>求解电子光谱项的程序</title>
    <url>/%E6%B1%82%E8%A7%A3%E7%94%B5%E5%AD%90%E5%85%89%E8%B0%B1%E9%A1%B9%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<ul>
<li><a href="#principle">表格法求光谱项的原理</a></li>
<li><a href="#thread">代码的思路</a></li>
<li><a href="#further_development">进一步改进</a></li>
<li><a href="#final_version">最终版本</a></li>
<li><a href="#references">参考文献</a></li>
</ul>

<p>Update(2017/10/6):该程序终于实现了直接输出光谱项的功能，因此将文章的标题和链接都修改为「求解电子光谱项的程序」。</p>
<p>求原子光谱项有很多种方法，这里只介绍一种思路简单粗暴的方法。某种程度上可称为是逐一枚举的方法。（等你看完说不定会觉得这个方法很low23333）</p>
<p>其实该方法也可看作是结构化学教科书上讲解两个同科电子组态（$ (n\text{p})^2 $）的光谱项的方法的推广。<br><a id="more"></a></p>
<h1 id="principle">表格法求光谱项的原理</h1>

<p>为什么某一组态的能级会发生分裂呢？这是因为该组态是简并的（没有某些扰动的理想条件下），而当考虑了扰动后，原本简并的微观能级不再简并而发生分裂。</p>
<p>我们知道，对于多电子原子中的任意一个电子，其状态可由其单电子原子轨道（波函数）近似描述，其中单电子波函数含有四个量子数。也就是说只要确定了这四个量子数，便能够确定其状态。而组态只能确定电子的主量子数$n$和角量子数$l$，并没有进一步描述电子的磁量子数$m$和自旋磁量子数$m_s$。</p>
<p>组态的能级分裂就是因为电子的磁量子数和自旋磁量子数的不同，虽然对于多电子原子来说使用总角量子数$L$、总自旋量子数$S$和总量子数$J$的概念会更合适。</p>
<p>所以该方法的第一步是确定某一组态的所有微观能态。</p>
<p>以$\text{d}^3$组态为例。我们首先要考虑其所有的电子排布方式。由于Pauli原理的限制，电子的状态没有完全相同的。d轨道有10个对应的自旋轨道，所以总的微观状态数为$\left( \begin{smallmatrix} 10 \\ 3 \end{smallmatrix} \right)=120$。</p>
<p>以图所示的状态为例，三个电子的磁量子数分别为2、2、1，所以$M_L=5$。而总自旋磁量子数$M_S=1/2$。</p>
<p><img src="../images/2017-08-21-1.png" alt=""></p>
<p>也就是我们要计算一共120种微观能态的$M_L$和$M_S$。如果手算的话，显然这是一个很麻烦的事情。</p>
<p>当我们将120种组合的$M_L$和$M_S$都算出来后，就可绘制出$M_L$-$M_S$表格。</p>
<p>以总自旋磁量子数为例，三个电子共有四种情况。电子的自旋全部相同以及其中一个电子与另外两个的自旋不同。所以$M_S=3/2, 1/2, -1/2, -3/2$。</p>
<p>相应地，$M_L=5, 4, 3,\ldots,-4, -5$。我们将各个组合中具有相同$M_L$、$M_S$分别计数，便可得到该表。</p>
<p><img src="../images/2017-08-21-2.png" alt=""></p>
<p>然后只需要一步步从表中提取出光谱项即可。</p>
<p><img src="../images/2017-08-21-3.png" alt=""></p>
<p>从最大的$M_L=5$开始看。$M_L$为$L$的最大值，$L$的取值范围为$0, 1,\ldots,\pm L$。而且对应的$S(M_S)=1/2, -1/2$。由此我们可推断出该组态有一$^2\text{H}$的光谱项。</p>
<p>然后我们将表格中二三列的数字均减去1，将该光谱项移除，得到第二步的表。</p>
<p>下图左边的是第二步得到的表，此时$L=3\ldots-3$，而$S=3/2, 1/2, -1/2, -3/2$。所以可提取出光谱项$^4\text{F}$。</p>
<p><img src="../images/2017-08-21-4.png" alt=""></p>
<p>最后得到的$\text{d}^3$组态的所有的光谱项为：$^2\text{H},\ ^2\text{G},\ ^4\text{F},\ ^2\text{F},\ ^2\text{D}(2),\ ^4\text{P},\ ^2\text{P}$</p>
<p>以上方法适用于任何同科电子组态光谱项的求算。而对于存在不同角量子数电子的组态（例如$\text{p}^2\text{d}^2$），只需要先分别求得p轨道的电子以及d轨道的电子的组合，再将不同角量子数的组合再一次组合即可。以$\text{p}^2\text{d}^2$组态为例，此时总的微观状态数为$\left( \begin{smallmatrix} 6 \\ 2 \end{smallmatrix} \right)\times\left( \begin{smallmatrix} 10 \\ 2 \end{smallmatrix} \right)=15\times 45=675$。这一方法说不上很高效，但思路很简单。之后生成表格的步骤则是完全一样的。</p>
<h1 id="thread">代码的思路</h1>

<p>我是用Fortran写的这个程序。下面主要介绍代码的思路。</p>
<p>代码运行示例：<br><img src="../images/2017-08-21-5.png" alt=""></p>
<p>我目前是实现了d轨道任意个同科电子组态的光谱项的辅助程序。不过将其推广至p、f、g轨道的难度都不大，就不细讲了。</p>
<p>d轨道共有10个自旋轨道，所以声明了两个含有10个元素的数组分别储存各自旋轨道的磁量子数和自旋磁量子数。</p>
<p>电子数是由用户输入的，然后依次列举所有的自旋轨道的组合并计算$M_L$和$M_S$并分别储存在两个数组中。这里需要注意，由于电子数并非事先写在程序中，所以列举组合的部分无法直接使用嵌套的循环来做到。这里使用的是一个利用递归的子程序来实现的。</p>
<p>然后统计$M_L$和$M_S$的取值各有多少种，并生成两个数组分别储存这些值（按由大到小的顺序依次储存）。</p>
<p>例如：120种组合的$M_L$依次为(5, 3, 2, 3, -1, 5, 4, -2,…)，而之后的那个数组为(5, 4, 3, 2,…,-4, -5)这11个值。</p>
<p>我们将前一个数组中的120个值与后一个数组进行比较，记录各个值出现的次数，便能够生成表中的数据。</p>
<p>Update(2017/8/30):将程序功能拓展了，现在可以处理不同角量子数的电子组态，如$({\rm s})^1({\rm p})^2({\rm d})^2$这样的组态。但无法处理如$(2{\rm p})^2(3{\rm p})^2$这一类的组态。</p>
<p>运行示例：<br><img src="../images/2017-8-30-1.png" alt=""></p>
<p>关于直接输出光谱项的功能的实现</p>
<p>由于直接对输出的表格进行操作很麻烦，而且也不必要（因为对整个表格操作需要的循环实现困难，而且表无论是行还是列都是对称的）。所以为了实现该功能，我首先取原有的表格的左上部分单独存为一个如图所示的二维数组。<br><img src="../images/2017-8-30-1.png" alt=""></p>
<p>之后检查第一行各列的数字$n$，若为零，则跳过；若非零，则根据其对应的总角量子数$L$和总自旋角量子数$S$得到其光谱项（若不为1，输出的光谱项后会有类似 <code>&#60;n&#62;</code> 的标记，表明该光谱项的数目为$n$），之后的各行与各列都减去$n$。一行结束后，进入下一行，重复以上的步骤。（没看明白的话，可以按照第一节的例子跟着手算一下）</p>
<p>最终得到的结果是<br><img src="../images/2017-10-6.png" alt=""></p>
<h1 id="further_development">进一步改进</h1>

<p>（很开心，这里提及的功能都已基本实现。当然以后依然会对代码进行完善。）<br>这里倒不是指代码的优化。目前希望是拓展该程序的功能，使之能够处理任意组态，并生成相应的表。</p>
<p>由于快到了回学校的时间，我把写代码的事暂时停下了，该功能要搁置一段时间才能完成。</p>
<p>至于为什么不直接输出所有的光谱项，很简单，我还没想出来怎么实现……</p>
<p>所以目前这都只能算是一个求光谱项的辅助程序。不过我还是挺高兴能写出这么一个玩意的。</p>
<h1 id="final_version">最终版本</h1>
Update(2019/7/16): <del>最终版本之再也不改了</del>

进一步学习了Fortran的指针和面向对象编程后，实现了多个相同壳层作为输入的功能。并且把原来的代码几乎重写了一遍。我用gfortran 8编译通过，在gfortran 7上应该也能编译（Intel Visual Fortran肯定也没问题）。代码可以在<a href="https://github.com/St-Maxwell/TermSymbolProgram" target="_blank" rel="noopener">GitHub</a>下载到，没有提供可执行文件（因为之前编译的程序在我现在的电脑上都运行不了，没有安装IVF）。当然如果你不想自己编译的话，我还是可以提供编译好的程序。

以下是运行的例子。
![](../images/2019-07-16_21-37-51.png)

<h1 id="references">参考文献</h1>

<ol>
<li><cite lang="en">Journal of Chemical Education</cite>, 52(2), <strong>1975</strong>:87-89</li>
<li><cite>大学化学</cite>, 29(2), <strong>2014</strong>:44-46</li>
</ol>]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>光谱项</tag>
      </tags>
  </entry>
  <entry>
    <title>Sob对Exploring Chemistry第三版的批判</title>
    <url>/Sob%E5%AF%B9Exploring-Chemistry%E7%AC%AC%E4%B8%89%E7%89%88%E7%9A%84%E6%89%B9%E5%88%A4/</url>
    <content><![CDATA[<p>一直以来就听说Exploring Chemistry一书的第三版非常不靠谱。刚刚在群里看到Sobereva老师对该书进行了大量的批判（原话：「本来想写个系统性的第三版的大批判，但现在没兴致了，上面只是放出了一部分之前忍不住吐槽的」）。虽然并没有涉及到原书的全部，但个人觉得应该是非常有参考价值的，所以决定收录于此。（应该不涉及侵犯著作权吧？）</p>
<p>以下均为Sob的原文：<br><a id="more"></a></p>
<hr />

<p>光是第一章我就写了一堆吐槽：</p>
<p>维他命D全是废话，看着都烦</p>
<p>计算中的重要经验技巧，如解决不收敛都没提。没有系统性讲讲关键词的使用。空话却很多。</p>
<p>11页对弥散函数的描述有误导性。哪仅限于sp的弥散。超极化率、偶极矩都不提。</p>
<p>通篇把6-311+G(2d,p)当标准基组，害人！<br>第12页的表格，明显可见，对于DFT，6-311G&#42;优化和CBS没什么差异，而书中不提3-zeta的重要，却提加了弥散函数比6-31G&#42;的改进。明显6-31+G&#42;和6-311(d)对于当前问题后者更小，结果更好。<br>也不提CCSD(T)和DFT用的基组要注意差异</p>
<p>一开始就说道密度拟合基组，但这几乎用不着，也没说清楚，干嘛跟初学者提。</p>
<p>14页简直瞎出主意，直接B3LYP优化多好。而且根本不需要弥散函数，还不如把计算量剩下来用混合基组呢。本来算单点也不花多少时间，又是关键，用ONIOM适得其反。或者干脆告诉大家，可以把长链截短。而且表里也没个对比，比如APFD算整个体系当精确结果（或者去掉弥散便宜点，用TZVP这个档），却用ONIOM的当精确值。</p>
<p>23页居然用那么烂的计算级别，还用MP2。还用大基组算频率</p>
<p>55页居然讨论「原子自旋密度」</p>
<p>通篇都在用6-311+G(2d,p)，居然不知道mulliken电荷不兼容弥散函数</p>
<p>p158说g09支持W2，但根本不支持</p>
<p>讲双正交化，还不如用自旋密度容易理解呢。老提到NBO，却不说一下NBO是个啥。</p>
<p>算热力学数据都不提频率校正因子</p>
<p>书中优化总用HF/6-31G*，不知想什么呢，单点用APFD就罢了，优化用HF找审稿人骂呢</p>
<p>76页，居然用CCSD结合那么烂的基组，还算频率，匪夷所思</p>
<p>测试数据老是想往APFD上贴金，老说比更昂贵的MP2好，却不拿对于当前问题好的泛函比，比如M062X</p>
<p>83页的耗时测试很有误导性，线性体系标度低，实际那可能这样。算不同大小的团簇还有得说。</p>
<p>第三章</p>
<p>各种用QST2、QST3，opt=TS却很少说，但实际上QST3根本没用，QST2也明显不如opt=TS好用。</p>
<p>opt=TS居然不用noeigen</p>
<p>103对虚频的处理方式根本不对。&gt;=1虚频时只有约束到了高对称性时扭曲结构通常才有效。虚频&gt;=1也未必是鞍点</p>
<p>102页找到的TS根本就连不通azirine</p>
<p>108页一大堆都不知道想表达什么。关键的，比如热力学量的关系没说，没用的倒说一堆。</p>
<p>113页的比较莫名其妙，什么也没说明，读者只会看了糊涂。直接拿双杂化算一下多好</p>
<p>117页坑爹。没找对过渡态，换初猜、calcfc啊</p>
<p>第四章</p>
<p>APFD/6-311 +G(2d ,p)用B3LYP/6-311+G(3df,2p)的校正因子却不做解释。热力学量至少也应该用ZPE校正因子。</p>
<p>145p，scale根本不影响输出的频率，居然说影响</p>
<p>p154，非要用APFD结合大基组，结果明显没B3LYP/6-31G*与实验相符更好。费力不讨好</p>
<p>p156都没说清楚绝热和垂直IP/EA的区别。</p>
<p>p169，对问题有点回避，对于C7，不考虑权重平均结果反倒好。而且考虑构象平均只考虑了C1。明显是个不成功的例子。这种体系用热力学组合方法多好。</p>
<p>p172 想不出丙酮有什么难优化的。增加积分格点纯粹扯淡。</p>
<p>p189，莫名其妙，明明众所周知B3LYP/6-31G*又快又特别理想，却不用</p>
<p>超极化率计算烂成一锅粥。符号不对。数据混乱，基组太烂</p>
<p>p194 用int=ultrafine纯属胡来，其实CPHF=grid=fine才是关键</p>
<p>p196 BD用6-31G*算单点，APFD用6-311+G(2d,p)优化，简直脑子进水了…</p>
<p>&nbsp;</p>
]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>计算化学</tag>
      </tags>
  </entry>
  <entry>
    <title>氢原子径向波函数数值求解</title>
    <url>/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%BE%84%E5%90%91%E6%B3%A2%E5%87%BD%E6%95%B0%E6%95%B0%E5%80%BC%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<p>在此之前，我已经写了一段数值求解一维量子谐振子波函数的Python代码。建议先从该帖子开始阅读（<a href="https://www.kechuang.org/t/81454" target="_blank" rel="noopener">Numerov方法数值求解一维量子谐振子波函数</a>），涉及到的Numerov方法的原理就不再重复了。<br><a id="more"></a><br>首先写出径向部分的Schroedinger方程：</p>
<script type="math/tex; mode=display">-\frac{\hbar^2}{2m} \left( R^{\prime\prime} + \frac{2}{r} R^\prime \right)+\frac{l(l+1)\hbar^2}{2mr^2} R+V(r)R=ER</script><p>由于Numerov方法处理的是形如$\psi^{\prime\prime}=G(r)\psi(r)$的微分方程，但上式中存在$R^\prime$项，所以需要消掉。</p>
<p>令$F(r)=rR(r)$，所以：</p>
<script type="math/tex; mode=display">R(r)=r^{-1}F(r)</script><script type="math/tex; mode=display">R^\prime=-r^{-2}F+r^{-1}F^\prime,\ R^{\prime\prime}=2r^{-3}F-2r^{-2}F^\prime</script><p>代入到径向Schroedinger方程中：</p>
<script type="math/tex; mode=display">-\frac{\hbar^2}{2m} F^{\prime\prime}(r)+ \left[ V(r)+\frac{l(l+1)\hbar^2}{2mr^2} \right]F(r)=EF(r)</script><script type="math/tex; mode=display">F^{\prime\prime}(r)=G(r)F(r),\ G(r)=\frac{m}{\hbar^2} \left(2V-2E \right)+\frac{l(l+1)}{r^2}</script><p>递推关系已得到，现在需要讨论边值条件。由于$r\rightarrow 0$时，$R(r)\sim r^l,\ l=0,1,2,\ldots,n$，因此$F=rR$在$r=0$处必为0。</p>
<p>但是这里有一个小问题，$r=0$时，前式中$G(r)$会遇到除以0的情况。为了避免这一情况，我们以一个非常小的$r$作为近似零点（比如令$r=10^{-15}$）。（但是又会带来另一个问题，对于$l=0$的径向波函数，$R(r)|_{r=0}$本应为一非零正值。但我们用该方法产生的结果是在（近似）零点处，波函数为0。然而目前暂时不知道如何处理）</p>
<p>在使用程序实现之前，还是先完成公式的非量纲化。（具体步骤不写了）</p>
<script type="math/tex; mode=display">V_\text{r} =-\frac{e^2}{4\pi\epsilon_0 r}=-\frac{e^{\prime 2}}{r_\text{r}}</script><script type="math/tex; mode=display">E_\text{r} =\frac{E}{\mu e^{\prime 4} \hbar^{-2}}=-\frac{e^{\prime 2}}{2n^2}</script><p>得到约化的Schroedinger方程和递推项分别为：</p>
<script type="math/tex; mode=display">F^{\prime\prime}_\text{r}=G_\text{r}F_\text{r},\ G_\text{r}=\frac{l(l+1)}{r_\text{r}^2}-\frac{2}{r_\text{r}}-2E_\text{r}</script><p>现在就可以使用程序实现了（和之前那个区别不大）。</p>
<p>写的Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">R=&#123;<span class="string">"r0"</span>:<span class="number">1e-15</span>&#125;</span><br><span class="line">F=&#123;<span class="string">"f0"</span>:<span class="number">0.0</span>&#125;</span><br><span class="line">G=&#123;<span class="string">"g0"</span>:<span class="number">0.0</span>&#125;</span><br><span class="line">nn=<span class="number">0</span></span><br><span class="line"> </span><br><span class="line">l=float(input(<span class="string">"Enter angular quantum number(l&gt;=0):"</span>))</span><br><span class="line">s=float(input(<span class="string">"Enter the increment sr:"</span>))</span><br><span class="line">m=int(input(<span class="string">"Enter the number of intervals m:"</span>))</span><br><span class="line">E=float(input(<span class="string">"Enter the reduced energy Er:"</span>))</span><br><span class="line"> </span><br><span class="line">F[<span class="string">"f1"</span>]=<span class="number">0.0001</span></span><br><span class="line">R[<span class="string">"r1"</span>]=R[<span class="string">"r0"</span>]+s</span><br><span class="line">G[<span class="string">"g0"</span>]=l*(l+<span class="number">1</span>)/(R[<span class="string">"r0"</span>]**<span class="number">2</span>)<span class="number">-2</span>/R[<span class="string">"r0"</span>]<span class="number">-2</span>*E</span><br><span class="line">G[<span class="string">"g1"</span>]=l*(l+<span class="number">1</span>)/(R[<span class="string">"r1"</span>]**<span class="number">2</span>)<span class="number">-2</span>/R[<span class="string">"r1"</span>]<span class="number">-2</span>*E</span><br><span class="line">ss=s*s/<span class="number">12</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">  R[<span class="string">"r%s"</span> % (i+<span class="number">1</span>)]=R[<span class="string">"r%s"</span> % i]+s</span><br><span class="line">  G[<span class="string">"g%s"</span> % (i+<span class="number">1</span>)]=l*(l+<span class="number">1</span>)/(R[<span class="string">"r%s"</span> % (i+<span class="number">1</span>)]**<span class="number">2</span>)<span class="number">-2</span>/R[<span class="string">"r%s"</span> % (i+<span class="number">1</span>)]<span class="number">-2</span>*E</span><br><span class="line">  F[<span class="string">"f%s"</span> % (i+<span class="number">1</span>)]=(-F[<span class="string">"f%s"</span> % (i<span class="number">-1</span>)]+<span class="number">2</span>*F[<span class="string">"f%s"</span> % i]+<span class="number">10</span>*G[<span class="string">"g%s"</span> % i]*F[<span class="string">"f%s"</span> \</span><br><span class="line">   % i]*ss + G[<span class="string">"g%s"</span> % (i<span class="number">-1</span>)]*F[<span class="string">"f%s"</span> % (i<span class="number">-1</span>)]*ss)/(<span class="number">1</span>-G[<span class="string">"g%s"</span> % (i+<span class="number">1</span>)]*ss)</span><br><span class="line">  <span class="keyword">if</span> (F[<span class="string">"f%s"</span> % i]*F[<span class="string">"f%s"</span> % (i+<span class="number">1</span>)]&lt;<span class="number">0</span>):</span><br><span class="line">    nn=nn+<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">"Er="</span>+str(E))</span><br><span class="line">print(<span class="string">"Nodes="</span>+str(nn))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">  print(<span class="string">"%f %f"</span> % (R[<span class="string">"r%s"</span> % i],(F[<span class="string">"f%s"</span> % i]/R[<span class="string">"r%s"</span> % i])))</span><br></pre></td></tr></table></figure>
<p>运行该程序需要我们输入角量子数、间隔长度、间隔数和能量。</p>
<p>例如，我们想绘制4p轨道径向部分波函数的图像。首先估计能量：$E\text{r}=-\frac{1}{2\times 4^2}=-0.03125$。然后由$-0.03125=-\frac{1}{r_\text{r}}$得到$r=32$。稍取更远的点$r=36$来验证波函数在此处是否趋于0。设间隔长度为0.1，间隔数自然为360。得到结果如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Er=<span class="number">-0.03125</span></span><br><span class="line">Nodes=<span class="number">2</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span></span><br><span class="line"><span class="number">0.100000</span> <span class="number">0.001000</span></span><br><span class="line"><span class="number">0.200000</span> <span class="number">0.001811</span></span><br><span class="line"><span class="number">0.300000</span> <span class="number">0.002567</span></span><br><span class="line"><span class="number">0.400000</span> <span class="number">0.003247</span></span><br><span class="line"><span class="number">0.500000</span> <span class="number">0.003852</span></span><br><span class="line"><span class="number">0.600000</span> <span class="number">0.004385</span></span><br><span class="line"><span class="number">0.700000</span> <span class="number">0.004853</span></span><br><span class="line"><span class="number">0.800000</span> <span class="number">0.005258</span></span><br><span class="line"><span class="number">0.900000</span> <span class="number">0.005605</span></span><br><span class="line"><span class="number">1.000000</span> <span class="number">0.005899</span></span><br><span class="line"><span class="number">1.100000</span> <span class="number">0.006143</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>用以上数据绘图，可看到与解析解得到的结果非常接近。（注：程序输出的数值与波函数的表达式算出的结果并不一定相同，这是因为没有对数值计算得到的结果进行归一化，将其乘以适当的系数后与理论值基本一致。）</p>
<p><img src="../images/2017-03-11-Graph.png" alt=""></p>
<p>之前提到了，对于s轨道，该程序有一些缺陷，由下图可以看出：</p>
<p><img src="../images/2017-03-11-Graph1.png" alt=""></p>
<p>当$r=0$时，$R(r)$本不为0，所以上图在零点附近的表现不太正确（后面是比较吻合的）。</p>
]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
