<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>电子积分库Libcint的用法</title>
    <url>/use-libcint/</url>
    <content><![CDATA[<p><a href="https://github.com/sunqm/libcint" target="_blank" rel="noopener">libcint</a>是Sun Qiming写的电子积分库，有Fortran接口。我想以后使用它写点小玩意。现在先尝试搞懂它的用法，并分享自己的一点经验。</p>
<p>当然最重要的是看libcint自己的手册（和GitHub仓库里的例子），然后可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/AULtH_7iPnaA8g5y46T_HQ" target="_blank" rel="noopener">Libcint电子积分库使用教程</a><br><a id="more"></a><br>计算积分前要先将每一个primitive Gaussian函数（直接从基组文件里读取的）归一化，然后将重叠矩阵的对角元归一化。</p>
<p>调用<code>CINTgto_norm</code>函数，它接受primitive Gaussian函数的总角动量<code>angl</code>（笛卡尔型Gaussian函数的总角动量$l=l_x+l_y+l_z$）和指数项<code>expnt</code>（$\alpha$）。乘到primitive Gaussian函数对应的收缩系数<code>cntr_coeff</code>即可。<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">cntr_coeff = cntr_coeff * CINTgto_norm(angl, expnt)</span><br></pre></td></tr></table></figure></p>
<p>我写了一个简单的测试（比较随意，有些地方是写死的），计算了水分子的def2-SVP基组的电子积分。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mod_info</span><br><span class="line">    <span class="keyword">use</span> <span class="keyword">iso_fortran_env</span>, <span class="keyword">only</span>: r8 =&gt; real64</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">! molecule: water</span></span><br><span class="line">    <span class="comment">! basis set: def2-SVP</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: natm = <span class="number">3</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: nshl = <span class="number">12</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: nprm = <span class="number">22</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: nbas = <span class="number">24</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(nshl), <span class="keyword">parameter</span> :: cntr_odr = &amp;</span><br><span class="line">    [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(nshl), <span class="keyword">parameter</span> :: angl = &amp;</span><br><span class="line">    [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(nshl), <span class="keyword">parameter</span> :: shl_belong_to_atom = &amp;</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(nshl), <span class="keyword">parameter</span> :: sh_indx = &amp;</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nprm), <span class="keyword">parameter</span> :: expnt = &amp;</span><br><span class="line">    [ <span class="number">2266.1767785</span>, <span class="number">340.87010191</span>, <span class="number">77.363135167</span>, &amp;</span><br><span class="line">      <span class="number">21.479644940</span>, <span class="number">6.6589433124</span>, <span class="number">0.80975975668</span>, &amp;</span><br><span class="line">      <span class="number">0.25530772234</span>, <span class="number">17.721504317</span>, <span class="number">3.8635505440</span>, &amp;</span><br><span class="line">      <span class="number">1.0480920883</span>, <span class="number">0.27641544411</span>, <span class="number">1.2000000</span>, &amp;</span><br><span class="line">      <span class="number">13.0107010</span>, <span class="number">1.9622572</span>, <span class="number">0.44453796</span>, &amp;</span><br><span class="line">      <span class="number">0.12194962</span>, <span class="number">0.8000000</span>, <span class="number">13.0107010</span>, &amp;</span><br><span class="line">      <span class="number">1.9622572</span>, <span class="number">0.44453796</span>, <span class="number">0.12194962</span>, &amp;</span><br><span class="line">      <span class="number">0.8000000</span> ]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nprm), <span class="keyword">parameter</span> :: coeff = &amp;</span><br><span class="line">    [ -<span class="number">0.53431809926E-02</span>, -<span class="number">0.39890039230E-01</span>, -<span class="number">0.17853911985</span>, &amp;</span><br><span class="line">      -<span class="number">0.46427684959</span>, -<span class="number">0.44309745172</span>, <span class="number">1.0000000</span>, &amp;</span><br><span class="line">      <span class="number">1.0000000</span>, <span class="number">0.43394573193E-01</span>, <span class="number">0.23094120765</span>, &amp;</span><br><span class="line">      <span class="number">0.51375311064</span>, <span class="number">1.0000000</span>, <span class="number">1.0000000</span>, &amp;</span><br><span class="line">      <span class="number">0.19682158E-01</span>, <span class="number">0.13796524</span>, <span class="number">0.47831935</span>, &amp;</span><br><span class="line">      <span class="number">1.0000000</span>, <span class="number">1.0000000</span>, <span class="number">0.19682158E-01</span>, &amp;</span><br><span class="line">      <span class="number">0.13796524</span>, <span class="number">0.47831935</span>, <span class="number">1.0000000</span>, &amp;</span><br><span class="line">      <span class="number">1.0000000</span> ]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(<span class="number">3</span>,natm), <span class="keyword">parameter</span> :: geom = <span class="built_in">reshape</span>(&amp;</span><br><span class="line">    [ <span class="number">0.00000000</span>, -<span class="number">0.00000000</span>, -<span class="number">0.11085125</span>, &amp;</span><br><span class="line">      <span class="number">0.00000000</span>, -<span class="number">0.78383672</span>, <span class="number">0.44340501</span>, &amp;</span><br><span class="line">      <span class="number">0.00000000</span>, <span class="number">0.78383672</span>, <span class="number">0.44340501</span> ], [<span class="number">3</span>,natm])</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(natm), <span class="keyword">parameter</span> :: charge = [<span class="number">8</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span> mod_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mod_libcint</span><br><span class="line">    <span class="keyword">use</span> mod_info</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(:,:), <span class="keyword">allocatable</span> :: atm</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(:,:), <span class="keyword">allocatable</span> :: bas</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(:), <span class="keyword">allocatable</span> :: env</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: CHARGE_OF  = <span class="number">1</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: PTR_COORD  = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: NUC_MOD_OF = <span class="number">3</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: PTR_ZETA   = <span class="number">4</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: ATM_SLOTS  = <span class="number">6</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: ATOM_OF    = <span class="number">1</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: ANG_OF     = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: NPRIM_OF   = <span class="number">3</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: NCTR_OF    = <span class="number">4</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: KAPPA_OF   = <span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: PTR_EXP    = <span class="number">6</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: PTR_COEFF  = <span class="number">7</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: BAS_SLOTS  = <span class="number">8</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: PTR_ENV_START = <span class="number">20</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> set_libcint_input()</span><br><span class="line">        <span class="keyword">integer</span> :: off, prim_off</span><br><span class="line">        <span class="keyword">integer</span> :: iatom, ishl, iprim, ioff</span><br><span class="line">        <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">external</span> :: CINTgto_norm</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">allocate</span>(atm(ATM_SLOTS,natm))</span><br><span class="line">        <span class="built_in">allocate</span>(bas(BAS_SLOTS,nshl))</span><br><span class="line">        <span class="built_in">allocate</span>(env(PTR_ENV_START+<span class="number">3</span>*natm+<span class="number">2</span>*nprm))</span><br><span class="line">  </span><br><span class="line">        off = PTR_ENV_START</span><br><span class="line">        <span class="keyword">do</span> iatom = <span class="number">1</span>, natm</span><br><span class="line">            atm(CHARGE_OF,iatom) = charge(iatom)</span><br><span class="line">            atm(PTR_COORD,iatom) = off</span><br><span class="line">            atm(NUC_MOD_OF,iatom) = <span class="number">1</span></span><br><span class="line">            env(off+<span class="number">1</span>:) = geom(:,iatom)</span><br><span class="line">            off = off + <span class="number">3</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">        prim_off = <span class="number">1</span></span><br><span class="line">        <span class="keyword">do</span> ishl = <span class="number">1</span>, nshl</span><br><span class="line">            bas(ATOM_OF,ishl) = shl_belong_to_atom(ishl) - <span class="number">1</span></span><br><span class="line">            bas(ANG_OF,ishl) = angl(ishl)</span><br><span class="line">            bas(NPRIM_OF,ishl) = cntr_odr(ishl)</span><br><span class="line">            bas(NCTR_OF,ishl) = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">            bas(PTR_EXP,ishl) = off</span><br><span class="line">            ioff = <span class="number">0</span></span><br><span class="line">            <span class="keyword">do</span> iprim = prim_off, prim_off + cntr_odr(ishl)-<span class="number">1</span></span><br><span class="line">                env(off+<span class="number">1</span>+ioff) = expnt(iprim)</span><br><span class="line">                ioff = ioff + <span class="number">1</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">            off = off + cntr_odr(ishl)</span><br><span class="line">  </span><br><span class="line">            bas(PTR_COEFF,ishl) = off</span><br><span class="line">            ioff = <span class="number">0</span></span><br><span class="line">            <span class="keyword">do</span> iprim = prim_off, prim_off + cntr_odr(ishl)-<span class="number">1</span></span><br><span class="line">                env(off+<span class="number">1</span>+ioff) = coeff(iprim) * CINTgto_norm(angl(ishl), expnt(iprim))</span><br><span class="line">                ioff = ioff + <span class="number">1</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">            off = off + cntr_odr(ishl)</span><br><span class="line">  </span><br><span class="line">            prim_off = prim_off + cntr_odr(ishl)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> set_libcint_input</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> normalize()</span><br><span class="line">        <span class="keyword">integer</span> :: ishl, iprim</span><br><span class="line">        <span class="keyword">integer</span> :: di, dj</span><br><span class="line">        <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(:,:), <span class="keyword">allocatable</span> :: buf1e</span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">dimension</span>(<span class="number">2</span>) :: shls</span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">external</span> :: CINTcgto_spheric</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">do</span> ishl = <span class="number">1</span>, nshl</span><br><span class="line">            shls(<span class="number">1</span>) = ishl - <span class="number">1</span></span><br><span class="line">            shls(<span class="number">2</span>) = ishl - <span class="number">1</span></span><br><span class="line">            di = CINTcgto_spheric(ishl-<span class="number">1</span>, bas)</span><br><span class="line">            dj = CINTcgto_spheric(ishl-<span class="number">1</span>, bas)</span><br><span class="line">            <span class="built_in">allocate</span>(buf1e(di,dj))</span><br><span class="line">            <span class="keyword">call</span> cint1e_ovlp_sph(buf1e,shls,atm,natm,bas,nshl,env)</span><br><span class="line">            <span class="keyword">do</span> iprim = <span class="number">1</span>, cntr_odr(ishl)</span><br><span class="line">                env(bas(PTR_COEFF,ishl)+iprim) = env(bas(PTR_COEFF,ishl)+iprim) / <span class="built_in">sqrt</span>(buf1e(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">deallocate</span>(buf1e)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> normalize</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span> mod_libcint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> mod_info</span><br><span class="line">    <span class="keyword">use</span> mod_libcint</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: i, j, k, l, di, dj, dk, dl, x, y, z, w</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nbas,nbas) :: S</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nbas,nbas) :: T</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nbas,nbas) :: V</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(nbas,nbas,nbas,nbas) :: eri</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(:,:), <span class="keyword">allocatable</span> :: buf1e</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=r8), <span class="keyword">dimension</span>(:,:,:,:), <span class="keyword">allocatable</span> :: buf2e</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">dimension</span>(<span class="number">4</span>) :: shls</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: CINTcgto_spheric</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">call</span> set_libcint_input()</span><br><span class="line">    <span class="keyword">call</span> normalize()</span><br><span class="line">  </span><br><span class="line">    open(<span class="number">11</span>, <span class="keyword">file</span>=<span class="string">"int.txt"</span>)</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*) atm(CHARGE_OF,:) </span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*) atm(PTR_COORD,:) </span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*) atm(NUC_MOD_OF,:)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nshl</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">11</span>,<span class="string">"(*(I4))"</span>) bas(ATOM_OF,i), bas(ANG_OF,i), bas(NPRIM_OF,i), &amp;</span><br><span class="line">                            bas(NCTR_OF,i), bas(PTR_EXP,i), bas(PTR_COEFF,i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, <span class="built_in">size</span>(env)</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">11</span>,*) i, env(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nshl</span><br><span class="line">        shls(<span class="number">1</span>) = i - <span class="number">1</span></span><br><span class="line">        di = CINTcgto_spheric(i-<span class="number">1</span>, bas)</span><br><span class="line">        <span class="keyword">do</span> j = <span class="number">1</span>, nshl</span><br><span class="line">            shls(<span class="number">2</span>) = j - <span class="number">1</span></span><br><span class="line">            dj = CINTcgto_spheric(j-<span class="number">1</span>, bas)</span><br><span class="line">            <span class="built_in">allocate</span>(buf1e(di,dj))</span><br><span class="line">            x = sh_indx(i); y = sh_indx(j)</span><br><span class="line">            <span class="keyword">call</span> cint1e_ovlp_sph(buf1e,shls,atm,natm,bas,nshl,env)</span><br><span class="line">            S(x:,y:) = buf1e(:,:)</span><br><span class="line">            <span class="keyword">call</span> cint1e_kin_sph(buf1e,shls,atm,natm,bas,nshl,env)</span><br><span class="line">            T(x:,y:) = buf1e(:,:)</span><br><span class="line">            <span class="keyword">call</span> cint1e_nuc_sph(buf1e,shls,atm,natm,bas,nshl,env)</span><br><span class="line">            V(x:,y:) = buf1e(:,:)</span><br><span class="line">            <span class="built_in">deallocate</span>(buf1e)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nshl</span><br><span class="line">      shls(<span class="number">1</span>) = i - <span class="number">1</span></span><br><span class="line">      di = CINTcgto_spheric(i-<span class="number">1</span>, bas)</span><br><span class="line">      <span class="keyword">do</span> j = <span class="number">1</span>, nshl</span><br><span class="line">          shls(<span class="number">2</span>) = j - <span class="number">1</span></span><br><span class="line">          dj = CINTcgto_spheric(j-<span class="number">1</span>, bas)</span><br><span class="line">          <span class="keyword">do</span> k = <span class="number">1</span>, nshl</span><br><span class="line">              shls(<span class="number">3</span>) = k - <span class="number">1</span></span><br><span class="line">              dk = CINTcgto_spheric(k-<span class="number">1</span>, bas)</span><br><span class="line">              <span class="keyword">do</span> l = <span class="number">1</span>, nshl</span><br><span class="line">                  shls(<span class="number">4</span>) = l - <span class="number">1</span></span><br><span class="line">                  dl = CINTcgto_spheric(l-<span class="number">1</span>, bas)</span><br><span class="line">                  <span class="built_in">allocate</span>(buf2e(di,dj,dk,dl))</span><br><span class="line">                  x = sh_indx(i); y = sh_indx(j)</span><br><span class="line">                  z = sh_indx(k); w = sh_indx(l)</span><br><span class="line">                  <span class="keyword">call</span> cint2e_sph(buf2e,shls,atm,natm,bas,nshl,env,<span class="number">0</span>_8)</span><br><span class="line">                  eri(x:,y:,z:,w:) = buf2e(:,:,:,:)</span><br><span class="line">                  <span class="built_in">deallocate</span>(buf2e)</span><br><span class="line">              <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">          <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nbas</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">11</span>,<span class="string">"(*(F15.10))"</span>) S(i,:)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*)</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nbas</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">11</span>,<span class="string">"(*(F15.10))"</span>) T(i,:)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*)</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nbas</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">11</span>,<span class="string">"(*(F15.10))"</span>) V(i,:)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(<span class="number">11</span>,*)</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, nbas</span><br><span class="line">        <span class="keyword">do</span> j = <span class="number">1</span>, nbas</span><br><span class="line">            <span class="keyword">do</span> k = <span class="number">1</span>, nbas</span><br><span class="line">                <span class="built_in">write</span>(<span class="number">11</span>,<span class="string">"(*(F15.10))"</span>) eri(i,j,k,:)</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(<span class="number">11</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> main</span><br></pre></td></tr></table></figure>
<p>我们可以用Psi4的电子积分做对比。有些矩阵元的顺序不一样，这个很正常（2p壳层的3个基函数的顺序不同）。</p>
<p>Psi4获得电子积分的代码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> psi4</span><br><span class="line"></span><br><span class="line">mol = psi4.geometry(<span class="string">'''</span></span><br><span class="line"><span class="string">    O  0.00000000  -0.00000000 -0.11085125</span></span><br><span class="line"><span class="string">    H  0.00000000  -0.78383672  0.44340501</span></span><br><span class="line"><span class="string">    H  0.00000000   0.78383672  0.44340501</span></span><br><span class="line"><span class="string">    unit = au</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line">basis_set = <span class="string">"def2-SVP"</span></span><br><span class="line"></span><br><span class="line">wfn = psi4.core.Wavefunction.build(mol, basis_set)</span><br><span class="line">mints = psi4.core.MintsHelper(wfn.basisset())</span><br><span class="line"></span><br><span class="line"><span class="comment"># get integrals from psi4 module</span></span><br><span class="line">Enuc = mol.nuclear_repulsion_energy()</span><br><span class="line">S = np.asarray(mints.ao_overlap())</span><br><span class="line">V = np.asarray(mints.ao_potential())</span><br><span class="line">T = np.asarray(mints.ao_kinetic())</span><br><span class="line">I = np.asarray(mints.ao_eri())</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>量化编程</tag>
        <tag>Libcint</tag>
      </tags>
  </entry>
  <entry>
    <title>Fortran初学者配置指南</title>
    <url>/Fortran%E5%88%9D%E5%AD%A6%E8%80%85%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><h1>选择现代Fortran</h1><br>FORTRAN 77肯定是不要再学了，或者至少不要写F77（因为可能免不了要看旧代码，所以也许还是要学）。不够我想说的是，也不要一直留在Fortran 90/95，最好继续学习Fortran 2003/2008以及Fortran 2018的新特性。Fortran 2003/2008提供了近乎完全的面向对象（自定义类型、类型绑定过程、抽象类、继承、多态等）的支持，以及新的内置过程等。虽然不见得所有新特性都用得上，但我认为是值得学的。</p>
<p>关于书，彭国伦的《<cite lang="zh">Fortran 95程序设计</cite>》还是很优秀的，选择用这本书入门完全可以。但是既然推荐继续学习Fortran 2003/2008，肯定要看更多的书。直接学习Stephen J. Chapman的《<cite lang="zh">Fortran 95/2003程序设计</cite>》也可以，可惜这书的中译版质量有点那啥，比较在意的话还是看彭国伦的吧。其他的中文书就不太推荐了，比如《<cite lang="zh">Fortran权威指南</cite>》，声称涵盖了F2003，实际上只是提了一下（不到4页的内容）。P.S. 今年（2019年）有一本新的中文Fortran书《<cite lang="zh">FORTRAN程序设计权威指南</cite>》，看了一下目录，似乎介绍了F2003/2008的特性，也许值得一试（但仍然想吐槽标题用的是全部大写的FORTRAN）。<br><a id="more"></a><br>于是剩下的只有英文书。其实原则上看<cite lang="en">Modern Fortran Explained</cite>就足够了（这书似乎算是Fortran语言的Bible？），最新版包括了Fortran 2018的内容。除此之外我想推荐的是<cite lang="en">Modern Fortran in Practice</cite>，但是这个书并不是入门的教科书，而是以实际案例为主的cookbook。建议基本的语法都学会了之后再看。</p>
<p><h1>选择Fortran编译器</h1><br>编译器的选择也受现代Fortran这一选择的影响，也就是不推荐对新标准支持不好的编译器。当然实际上也受是否流行影响。至少我只会考虑gfortran、Intel Visual Fortran、PGI Fortran。</p>
<p>首先建议看一下各种Fortran编译器对语言标准的支持情况：<a href="http://fortranwiki.org/fortran/show/Fortran+2008+status" target="_blank" rel="noopener"><cite lang="en">Compiler Support for the Fortran 2008 Standard</cite></a>、<a href="http://fortranwiki.org/fortran/show/Fortran+2018+status" target="_blank" rel="noopener"><cite lang="en">Compiler Support for the Fortran 2018 Standard</cite></a></p>
<p>其实IVF是最受推荐的，但我并不打算介绍。因为IVF相当流行，所以我没必要再讲如何安装使用IVF。其次IVF是收费的，体积也非常大。我觉得除非需要做一些正经的工作，那么再考虑使用。当然IVF是可以以学生身份申请到免费的，这个就请自行解决（我申请过一次，但是被拒绝了……于是我用着盗版的IVF）。这里贴一下Visual Studio和IVF版本匹配的图（来自Fortran Coder群）：</p>
<p><img src="../images/2019-08-21-VSIVF.png" alt=""></p>
<p>VS和IVF建议安装较新的版本，2013版本什么的就别再用了。</p>
<p>这里顺便提一下PGI Fortran。PGF有免费的社区版，所以选择PGF就可以心安理得地用了。但是PGF的问题在于用起来相对比较麻烦，因为PGI Visual Fortran将被废除。实际上最新的PGF 19无法使用VS在GUI界面编写和编译，只能通过命令行使用（安装PGF时好像会附带一个基于Java的图形界面的调试器，但编辑和编译应该是没有自带的图形界面）。此外PGF仍然对VS有依赖，在安装PGF之前需要安装VS。</p>
<p>最终就是要介绍gfortran。gfortran是自由软件，体积小，对Fortran新标准支持较好，编译得到的程序执行速度也不错。所以也推荐使用（推荐程度大概是IVF&gt;gfortran&gt;PGF）。然后我还想多说一句，其实我很期待LLVM的Fortran编译器。LLVM之前有Flang编译器，但是这个Flang项目已经停了，将由F18编译器接替。F18编译器在今年年底应该会开发完，到时候想尝试一下。</p>
<p><h1>需要的软件和插件</h1><br>其实我不太想把配置的整个步骤都详细介绍。因为我嫌麻烦；另外这些东西要么有手册教程，要么其他人有写过文章介绍，我没必要写。所以有些地方我可能只会贴个链接。</p>
<p><h2>安装gfortran</h2><br>那么首先是安装gfortran。自行编译肯定不考虑，如果您能自行编译gfortran，那肯定没必要看我的文章了。我们选择直接下载已编译好的二进制文件。如果你搜索「安装gfortran」，绝大多数文章都是告诉你安装mingw-w64。但我更想推荐通过MSYS2安装gfortran。</p>
<p>首先进入<a href="https://www.msys2.org/" target="_blank" rel="noopener">www.msys2.org</a>下载安装MSYS2（我想大部分人应该都是选择x86_64），安装的方法根据网站首页的教程照着做即可。安装并配置好后，通过MSYS2的包管理程序下载安装gfortran。MSYS2的使用方法见<a href="https://github.com/msys2/msys2/wiki" target="_blank" rel="noopener">wiki</a>，我在这里介绍最重要的两个命令：<code>pacman -Ss</code>搜索程序，<code>pacman -S</code>安装程序。</p>
<p>首先安装gcc，输入<code>pacman -Ss gcc</code>，将会看到很多程序。需要安装的是x86_64的gcc（mingw-w64-x86_64-gcc）和名字里带有fortran的（全安装就是了）。依次输入<code>pacman -S mingw-w64-x86_64-gcc</code>安装gcc以及其他需要安装的程序即可。</p>
<p><img src="../images/2019-08-21-MSYS2.png" alt=""></p>
<p>安装完成之后，要设置gfortran、gdb的环境变量。这些程序的位置应该都在MSYS2安装文件夹的<code>mingw64\bin</code>这个位置下，把完整路径添加到<code>PATH</code>变量。我们打开终端（推荐Windows Terminal），输入<code>gfortran -v</code>，如果输出类似下图，说明安装成功。顺便也测试一下<code>gcc -v</code>和<code>gdb -v</code>看看是否正常。</p>
<p><img src="../images/2019-08-21-terminal.png" alt=""></p>
<p><h2>安装VS Code和插件</h2><br>推荐使用Visual Studio Code编辑器编写Fortran代码。安装VS Code就没必要教了，自行搜索安装即可。</p>
<p>关于插件，将按后述的具体需求依次介绍。<em>而且插件的设置因人而异，不必完全照抄我的，最好自己研究插件的manual</em>。</p>
<p>一定要安装的插件是<a href="https://marketplace.visualstudio.com/items?itemName=krvajalm.linter-gfortran" target="_blank" rel="noopener">Modern Fortran</a>，提供Fortran的语法高亮，语法检查等功能。插件安装之后，进入设置的JSON文件，添加以下设置<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"fortran.includePaths": [</span><br><span class="line">    "/usr/bin",</span><br><span class="line">    <span class="string">"C:\\msys64\\mingw64\\bin\\"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><br>告诉插件编译器的位置（第一个路径是WSL子系统里gfortran的路径，如果你不用WSL或其中没有安装gfortran，就不必写这个路径）。</p>
<p>此外推荐安装<a href="https://marketplace.visualstudio.com/items?itemName=hansec.fortran-ls" target="_blank" rel="noopener">FORTRAN IntelliSense</a>，用于Fortran代码的智能提示。</p>
<p><img src="../images/2019-08-21-fortranIntellisense.png" alt=""></p>
<p>安装这个插件前需要安装<a href="https://github.com/hansec/fortran-language-server" target="_blank" rel="noopener">fortran-language-server</a>，安装方法也很简单，<code>pip install fortran-language-server</code>即可。什么？不知道<code>pip</code>是什么？这年头还能不会一点Python吗？快安装Python和pip。</p>
<p><h2>编译和运行</h2><br>首先我要说明一点，这一段提供的方法仅适用于比较简单的编译或者例行的编译。对于较大的工程，应该选择Make，但是我目前也不懂这个，如果有需求请自行学习。</p>
<p>这一功能由<a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner" target="_blank" rel="noopener">Code Runner</a>插件提供。添加以下设置<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"code-runner.executorMapByFileExtension": &#123;</span><br><span class="line">    ".f90": "cd $dir &amp;amp;&amp;amp; gfortran -c *.f90 &amp;amp;&amp;amp; gfortran -o $fileNameWithoutExt *.o &amp;amp;&amp;amp; $dir$fileNameWithoutExt",</span><br><span class="line">    ".c": "cd $dir &amp;amp;&amp;amp; gcc $fileName -o $fileNameWithoutExt &amp;amp;&amp;amp; $dir$fileNameWithoutExt"</span><br><span class="line">&#125;,</span><br><span class="line">"code-runner.saveFileBeforeRun": true,</span><br><span class="line">"code-runner.defaultLanguage": "fortran",</span><br><span class="line">"code-runner.runInTerminal": true,</span><br></pre></td></tr></table></figure><br>我这里把C的配置也写进去了。Fortran那部分的命令其实是</p>
<p><pre>1. cd 到当前目录</p>
<ol>
<li>gfortran -c *.f90  编译当前目录下所有.f90文件</li>
<li>gfortran -o $fileNameWithoutExt *o  链接.o文件得到可执行文件，可执行文件的名字是$fileNameWithoutExt，指不包含拓展名的当前文件的名字。</li>
<li>/$fileNameWithoutExt  运行编译得到的可执行文件。<br>&lt;/pre&gt;<br>点击右上角的三角形图标即可编译运行代码。<br><img src="../images/2019-08-21-VSCode.png" alt=""></li>
</ol>
<p>再强调一遍，这个配置仅供参考，并且对于需要额外的编译选项或复杂工程这个插件并不够用。</p>
<p><h2>调试</h2><br>程序的调试使用gdb，教程可以看<a href="https://oi.men.ci/gnu-debugger/" target="_blank" rel="noopener">GDB 入门教程</a>。</p>
<p>完全使用命令行的gdb调试也是可以的，但我介绍两个基于gdb的图形界面调试方法。</p>
<p>第一个是使用VS Code的插件，因为有一篇文章已经介绍过了，所以我只贴链接：<a href="https://www.jianshu.com/p/98e16631c852" target="_blank" rel="noopener">Visual Studio Code 搭建 Fortran 调试环境</a></p>
<p>第二个是使用<a href="https://www.gdbgui.com/" target="_blank" rel="noopener">gdbgui</a>，安装很简单，<code>pip install gdbgui</code>就完事儿了。</p>
<p>运行的方法是<code>gdbgui xxx.exe</code>，将在浏览器中打开调试界面。</p>
<p><img src="../images/2019-08-21-gdbgui.png" alt=""></p>
<p>可以在底部输入gdb的命令。总之请自行把玩。</p>
]]></content>
      <categories>
        <category>Fortran</category>
      </categories>
  </entry>
  <entry>
    <title>利用.fch文件计算电子密度的代码</title>
    <url>/calculating-electron-density-with-fch-file/</url>
    <content><![CDATA[<p>最近在看密度泛函的书，于是就想自己写一个能计算电子密度的程序，这样就可以具体地了解一些体系。而且由于更早一些时候才正经学了基组的知识，想弄清楚怎么把市面上的基组放在程序中使用（之前写HF程序用的是STO-3G，不涉及到分裂价层，而且没有涉及更多的壳层）。所以写这么一个程序还是可以帮我学到很多东西的。</p>
<p>代码上传到GitHub：<a href="https://github.com/St-Maxwell/ElectronDensity" target="_blank">https://github.com/St-Maxwell/ElectronDensity</a></p>
<p>参考了Sobereva的文章：<a href="http://sobereva.com/55" target="_blank">高斯fch文件与wfn波函数文件的介绍及转换方法</a>、<a href="http://sobereva.com/182" target="_blank">利用wfn文件计算电子密度的代码的编写方法</a>。<br><a id="more"></a></p>
<h1 id="电子密度">电子密度</h1>
在空间$\mathbf{r}$处找到任意一个电子的概率。

$$ \rho(\mathbf{r}) =  N \int |\Psi(\mathbf{x}_1, \mathbf{x}_2,\ldots,\mathbf{x}_N)|^2\, d\omega_1 d\mathbf{x}_2\ldots d\mathbf{x}_N $$

将上式展开为空间轨道（分子轨道）$\{\psi_a\}$，为

$$ \rho(\mathbf{r}) = 2 \sum\limits_a^{N/2} |\psi_a(\mathbf{r})|^2 $$

若是自然轨道，则为

$$ \rho(\mathbf{r}) = \sum\limits_a^{N/2} \lambda_a |\eta_a(\mathbf{r})|^2 $$

其中$\eta_a$是自然轨道，$\lambda$是自然轨道占据数。

实际计算中将用一组基函数将轨道展开，则密度的表达式可写为

$$ \rho(\mathbf{r}) = \sum\limits_a^{N/2} \lambda_a \left| \sum\limits_i C_{ai} \varphi_i(\mathbf{r}) \right|^2 $$

$C_{ai}$是展开系数，$\lambda_a$对于分子轨道就是$2$，对于自然轨道则是非整数。

基函数同样可以用一组Gaussian型函数（Gaussian Type Function，GTF）展开:

$$ \varphi = \sum\limits_i a_i \chi_i^\text{GTF}(x,y,z) $$

$a_i$是收缩系数，$\chi^\text{GTF}$假定是Cartesian型GTF，有如下形式

$$ \chi = N x^{l_x} y^{l_y} z^{l_z} \mathrm{e}^{-\zeta r^2} $$

归一化系数$N$的表达式为

$$ \begin{aligned} N &= \left( \frac{2\zeta}{\pi} \right)^{3/4} \left[ \frac{(4\zeta)^{l_x+l_y+l_z}}{(2l_x-1)!!(2l_y-1)!!(2l_z-1)!!} \right]^{1/2} \\ &= \left( \frac{2\zeta}{\pi} \right)^{3/4} \left[ \frac{(8\zeta)^{l_x+l_y+l_z}l_x!l_y!l_z!}{(2l_x)!(2l_y)!(2l_z)!} \right]^{1/2} \end{aligned} $$

<h2>电子密度的梯度</h2>
电子密度的梯度为

$$ \nabla \rho(\mathbf{r}) = \frac{\partial \rho(\mathbf{r})}{\partial x}\mathbf{x} + \frac{\partial \rho(\mathbf{r})}{\partial y}\mathbf{y} + \frac{\partial \rho(\mathbf{r})}{\partial z}\mathbf{z} $$

以$\partial \rho/\partial x$为例：

$$ \begin{aligned} \frac{\partial \rho}{\partial x} &= \frac{\partial}{\partial x} \sum\limits_a^{N/2} \lambda_a \psi_a^2(\mathbf{r}) \\ &= \sum\limits_a^{N/2} 2\lambda_a \psi_a(\mathbf{r}) \frac{\partial \psi_a(\mathbf{r})}{\partial x} \end{aligned} $$

分子轨道的导数最终可以用GTF的导数的线性组合表示：

$$ \frac{\partial \psi_a(\mathbf{r})}{\partial x} = \sum\limits_i C_{ai} \sum\limits_j a_{ij} \frac{\partial \chi_j(\mathbf{r})}{\partial x} $$

GTF关于$x$的导数很容易得到，为

$$ \frac{\partial \chi_j(\mathbf{r})}{\partial x} = (l_x x^{l_x-1} - 2\zeta x^{l_x+1}) N  y^{l_y} z^{l_z} \mathrm{e}^{-\zeta r^2} $$

梯度的模

$$ |\nabla \rho| = \sqrt{\bigg(\frac{\partial \rho}{\partial x}\bigg)^2 + \bigg(\frac{\partial \rho}{\partial y}\bigg)^2 + \bigg(\frac{\partial \rho}{\partial z}\bigg)^2} $$

<h1 id="需要从.fch文件读取的量">需要从.fch文件读取的量</h1>
波函数类型
如果是自然轨道，需要手动将<code>.fch</code>文件第一行内容改为<code>isNO</code>；
从第二行确定波函数为<code>R</code>、<code>U</code>、<code>RO</code>。若使用的方法首字母为O，且为闭壳层的情况，会误认为波函数为<code>RO</code>，虽然并不影响密度的计算。

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SP        RB3LYP                                   6-31G(d,p)</span><br><span class="line">电子数</span><br><span class="line">Number of electrons                        I               10</span><br><span class="line">Number of alpha electrons                  I                5</span><br><span class="line">Number of beta electrons                   I                5</span><br><span class="line">基函数数目</span><br><span class="line">Number of basis functions                  I               25</span><br><span class="line">收缩壳层数目</span><br><span class="line">Number of contracted shells                I               10</span><br><span class="line">原函数数目</span><br><span class="line">Number of primitive shells                 I               21</span><br><span class="line">壳层类型</span><br><span class="line">Shell types                                I   N&#x3D;          10</span><br><span class="line">每个壳层的收缩度</span><br><span class="line">Number of primitives per shell             I   N&#x3D;          10</span><br><span class="line">原函数的指数</span><br><span class="line">Primitive exponents                        R   N&#x3D;          21</span><br><span class="line">原函数收缩系数</span><br><span class="line">Contraction coefficients                   R   N&#x3D;          21</span><br><span class="line">原函数收缩系数（sp(p)型函数）</span><br><span class="line">P(S&#x3D;P) Contraction coefficients            R   N&#x3D;          21</span><br><span class="line">基函数坐标</span><br><span class="line">Coordinates of each shell                  R   N&#x3D;          30</span><br><span class="line">分子轨道系数</span><br><span class="line">Alpha MO coefficients                      R   N&#x3D;         625</span><br><span class="line">对于自然轨道，这一部分数据实际上是轨道占据数</span><br><span class="line">Alpha Orbital Energies                     R   N&#x3D;          25</span><br></pre></td></tr></table></figure>

<h1 id="fch文件波函数类型">.fch文件波函数类型</h1>
<h2 id="gaussian">Gaussian</h2>
<ul>
<li>限制性分子轨道
<ul>
<li>闭壳层：默认即可</li>
<li>限制性开壳层：<code>RO</code></li>
</ul></li>
<li>非限制性分子轨道
<ul>
<li>开壳层：默认即可</li>
<li>自旋极化单重态：<code>UHF/DFT guess=mix</code></li>
</ul></li>
<li>自然轨道
<ul>
<li><code>density=current</code> + <code>guess(save,only,naturalorbitals) chkbasis</code></li>
<li>限制性闭壳层：默认</li>
<li>非限制性开壳层：默认</li>
<li>限制性开壳层：不支持（<code>RO</code>后HF都没有解析梯度）</li>
<li>自旋极化单重态：以<code>UHF/DFT guess=mix</code>作为参考态</li>
<li>Gaussian输出的.fch中，自然轨道不包含自旋信息，其占据数为$0 \text{--} 2$。虽然会输出<code>beta</code>轨道信息，但实际上和<code>alpha</code>轨道的信息一模一样。</li>
</ul></li>
</ul>

<h1>用法</h1>

<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> m_basis_func</span><br><span class="line"><span class="keyword">use</span> m_routines</span><br><span class="line"><span class="keyword">type</span>(molecule) :: mol</span><br><span class="line"><span class="keyword">integer</span> :: iounit</span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">80</span>) filename</span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>) :: x, y, z</span><br><span class="line"></span><br><span class="line"><span class="comment">! read .fch file</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">"Input .fch file"</span></span><br><span class="line">read(*,*) filename</span><br><span class="line">open(<span class="keyword">newunit</span>=iounit, <span class="keyword">file</span>=filename, <span class="keyword">status</span>=<span class="string">'old'</span>, <span class="keyword">action</span>=<span class="string">'read'</span>)</span><br><span class="line"><span class="keyword">call</span> read_basis_func(iounit, mol)</span><br><span class="line"><span class="keyword">call</span> read_mo_coeff(iounit, mol)</span><br><span class="line">close(iounit)</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) mol%density(x, y, z, <span class="string">'t'</span>)</span><br><span class="line"><span class="comment">! 't' - total density</span></span><br><span class="line"><span class="comment">! 'a' - alpha density</span></span><br><span class="line"><span class="comment">! 'b' - beta density</span></span><br><span class="line"><span class="built_in">write</span>(*,*) mol%den_grad(x, y, z, <span class="string">'x'</span>)</span><br><span class="line"><span class="comment">! 'x' - x component of gradient</span></span><br><span class="line"><span class="comment">! 'y' - y component of gradient</span></span><br><span class="line"><span class="comment">! 'z' - z component of gradient</span></span><br><span class="line"><span class="comment">! 'm' - magnitude of gradient</span></span><br></pre></td></tr></table></figure>
<p><h1 id="例子">例子</h1></p>
<p><h2 id="textch_3自由基">$\text{CH}_3$自由基</h2><br><img src="../images/2019-08-05-CH3_density.png" alt=""><br>自由基所在平面上的电子密度。</p>
<p><h2 id="texth_2分子">$\text{H}_2$分子</h2><br><img src="../images/2019-08-05-H2_density.png" alt=""><br>$\text{H}_2$沿所在轴的电子密度，注意到在核的位置电子密度梯度不连续。</p>
<p><img src="../images/2019-08-05-H2_dengrad.png" alt=""><br>电子密度梯度的空间分布，分子所在轴为$z$轴。可以与上图电子密度的变化进行对照。</p>
]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>量化编程</tag>
        <tag>电子密度</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern Quantum Chemistry 习题解答</title>
    <url>/Modern-Quantum-Chemistry-%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/</url>
    <content><![CDATA[<p>昨天算是看完了 <cite lang="en">Modern Quantum Chemistry</cite>（第七章不打算看，微扰理论的图解部分跳过了），把写的习题解答发出来。</p>
<p>说明一下，这个答案绝对不可能完全没有错误，所以遇到怀疑有问题的地方还请自行思考（如果能给我反馈一下错误也最好不过了）。本来是想从头到尾校正一下，但实在没时间。打算复习一下笔记就去看别的书。<br><a id="more"></a><br>其次，不是所有的题目都写了。主要存在空缺的是第五章的习题，纯粹是我不想写（以后也许会补）。</p>
<p><a href="../files/Solutions-Manual-MQC.pdf">点此下载</a></p>
<p>里面没有中国字的原因是最早写的时候，用的<code>ctexart</code>类编译实在太慢，所以只能妥协用英语写。之后就是单纯沿袭这个习惯了。英语写得很拙劣，能理解就行。</p>
<p>另外提供一个有习题解答的<a href="http://www.claudiug.com/9780486691862/" target="_blank">网站</a> ，也可供参考（第六章微扰理论的习题解答是没有的）。</p>
<hr />

<p>五月的怨念：没有推导出三阶微扰校正的公式、没有完全看懂霍夫曼的PMO文献。</p>
]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
  </entry>
  <entry>
    <title>Ringo——我的第一个量化程序</title>
    <url>/ringo/</url>
    <content><![CDATA[<p>目前 <cite lang="en">Modern Quantum Chemistry</cite> 上氢分子和氦氢离子（HeH<sup>+</sup>）的两个例子已经学完了。</p>
<p>然后我就尝试写出了自己的第一个量化程序，用于 HeH<sup>+</sup> 的 RHF/STO-3G 的计算。</p>
<p>程序是用 Fortran 写的。<br><a id="more"></a><br>代码和文档上传到了Github：<a href="https://github.com/St-Maxwell/Ringo" target="_blank" rel="noopener">https://github.com/St-Maxwell/Ringo</a></p>
<p>因为基本上所有内容都在文档中，所以这里不再详细介绍了。</p>
<p>如果有人对量化编程有兴趣，希望我的代码和文档能帮助到你。</p>
<p>随着我未来对理论化学的学习，会逐渐为这个代码的增加更多的内容。</p>
<p>运行结果<br><img src="../images/2017-11-30-1.png" alt=""></p>
<p>与Gaussian的结果的对比<br><img src="../images/2017-11-30-2.png" alt=""></p>
<p><hr /><br>Update(2020/2/10): 现在使用了Libcint库计算电子积分，因此原来的代码已全部重写。现有的版本支持更多基组（主要是def2系列和相关一致基组），以及简单的输入文件解析。今后将以此为基础进行开发。</p>
]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>量化编程</tag>
      </tags>
  </entry>
  <entry>
    <title>求解电子光谱项的程序</title>
    <url>/%E6%B1%82%E8%A7%A3%E7%94%B5%E5%AD%90%E5%85%89%E8%B0%B1%E9%A1%B9%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<ul>
<li><a href="#principle">表格法求光谱项的原理</a></li>
<li><a href="#thread">代码的思路</a></li>
<li><a href="#further_development">进一步改进</a></li>
<li><a href="#final_version">最终版本</a></li>
<li><a href="#references">参考文献</a></li>
</ul>

<p>Update(2017/10/6):该程序终于实现了直接输出光谱项的功能，因此将文章的标题和链接都修改为「求解电子光谱项的程序」。</p>
<p>求原子光谱项有很多种方法，这里只介绍一种思路简单粗暴的方法。某种程度上可称为是逐一枚举的方法。（等你看完说不定会觉得这个方法很low23333）</p>
<p>其实该方法也可看作是结构化学教科书上讲解两个同科电子组态（$ (n\text{p})^2 $）的光谱项的方法的推广。<br><a id="more"></a></p>
<h1 id="principle">表格法求光谱项的原理</h1>

<p>为什么某一组态的能级会发生分裂呢？这是因为该组态是简并的（没有某些扰动的理想条件下），而当考虑了扰动后，原本简并的微观能级不再简并而发生分裂。</p>
<p>我们知道，对于多电子原子中的任意一个电子，其状态可由其单电子原子轨道（波函数）近似描述，其中单电子波函数含有四个量子数。也就是说只要确定了这四个量子数，便能够确定其状态。而组态只能确定电子的主量子数$n$和角量子数$l$，并没有进一步描述电子的磁量子数$m$和自旋磁量子数$m_s$。</p>
<p>组态的能级分裂就是因为电子的磁量子数和自旋磁量子数的不同，虽然对于多电子原子来说使用总角量子数$L$、总自旋量子数$S$和总量子数$J$的概念会更合适。</p>
<p>所以该方法的第一步是确定某一组态的所有微观能态。</p>
<p>以$\text{d}^3$组态为例。我们首先要考虑其所有的电子排布方式。由于Pauli原理的限制，电子的状态没有完全相同的。d轨道有10个对应的自旋轨道，所以总的微观状态数为$\left( \begin{smallmatrix} 10 \\ 3 \end{smallmatrix} \right)=120$。</p>
<p>以图所示的状态为例，三个电子的磁量子数分别为2、2、1，所以$M_L=5$。而总自旋磁量子数$M_S=1/2$。</p>
<p><img src="../images/2017-08-21-1.png" alt=""></p>
<p>也就是我们要计算一共120种微观能态的$M_L$和$M_S$。如果手算的话，显然这是一个很麻烦的事情。</p>
<p>当我们将120种组合的$M_L$和$M_S$都算出来后，就可绘制出$M_L$-$M_S$表格。</p>
<p>以总自旋磁量子数为例，三个电子共有四种情况。电子的自旋全部相同以及其中一个电子与另外两个的自旋不同。所以$M_S=3/2, 1/2, -1/2, -3/2$。</p>
<p>相应地，$M_L=5, 4, 3,\ldots,-4, -5$。我们将各个组合中具有相同$M_L$、$M_S$分别计数，便可得到该表。</p>
<p><img src="../images/2017-08-21-2.jpg" alt=""></p>
<p>然后只需要一步步从表中提取出光谱项即可。</p>
<p><img src="../images/2017-08-21-3.png" alt=""></p>
<p>从最大的$M_L=5$开始看。$M_L$为$L$的最大值，$L$的取值范围为$0, 1,\ldots,\pm L$。而且对应的$S(M_S)=1/2, -1/2$。由此我们可推断出该组态有一$^2\text{H}$的光谱项。</p>
<p>然后我们将表格中二三列的数字均减去1，将该光谱项移除，得到第二步的表。</p>
<p>下图左边的是第二步得到的表，此时$L=3\ldots-3$，而$S=3/2, 1/2, -1/2, -3/2$。所以可提取出光谱项$^4\text{F}$。</p>
<p><img src="../images/2017-08-21-4.png" alt=""></p>
<p>最后得到的$\text{d}^3$组态的所有的光谱项为：$^2\text{H},\ ^2\text{G},\ ^4\text{F},\ ^2\text{F},\ ^2\text{D}(2),\ ^4\text{P},\ ^2\text{P}$</p>
<p>以上方法适用于任何同科电子组态光谱项的求算。而对于存在不同角量子数电子的组态（例如$\text{p}^2\text{d}^2$），只需要先分别求得p轨道的电子以及d轨道的电子的组合，再将不同角量子数的组合再一次组合即可。以$\text{p}^2\text{d}^2$组态为例，此时总的微观状态数为$\left( \begin{smallmatrix} 6 \\ 2 \end{smallmatrix} \right)\times\left( \begin{smallmatrix} 10 \\ 2 \end{smallmatrix} \right)=15\times 45=675$。这一方法说不上很高效，但思路很简单。之后生成表格的步骤则是完全一样的。</p>
<h1 id="thread">代码的思路</h1>

<p>我是用Fortran写的这个程序。下面主要介绍代码的思路。</p>
<p>代码运行示例：<br><img src="../images/2017-08-21-5.jpg" alt=""></p>
<p>我目前是实现了d轨道任意个同科电子组态的光谱项的辅助程序。不过将其推广至p、f、g轨道的难度都不大，就不细讲了。</p>
<p>d轨道共有10个自旋轨道，所以声明了两个含有10个元素的数组分别储存各自旋轨道的磁量子数和自旋磁量子数。</p>
<p>电子数是由用户输入的，然后依次列举所有的自旋轨道的组合并计算$M_L$和$M_S$并分别储存在两个数组中。这里需要注意，由于电子数并非事先写在程序中，所以列举组合的部分无法直接使用嵌套的循环来做到。这里使用的是一个利用递归的子程序来实现的。</p>
<p>然后统计$M_L$和$M_S$的取值各有多少种，并生成两个数组分别储存这些值（按由大到小的顺序依次储存）。</p>
<p>例如：120种组合的$M_L$依次为(5, 3, 2, 3, -1, 5, 4, -2,…)，而之后的那个数组为(5, 4, 3, 2,…,-4, -5)这11个值。</p>
<p>我们将前一个数组中的120个值与后一个数组进行比较，记录各个值出现的次数，便能够生成表中的数据。</p>
<p>Update(2017/8/30):将程序功能拓展了，现在可以处理不同角量子数的电子组态，如$({\rm s})^1({\rm p})^2({\rm d})^2$这样的组态。但无法处理如$(2{\rm p})^2(3{\rm p})^2$这一类的组态。</p>
<p>运行示例：<br><img src="../images/2017-8-30-1.png" alt=""></p>
<p>关于直接输出光谱项的功能的实现</p>
<p>由于直接对输出的表格进行操作很麻烦，而且也不必要（因为对整个表格操作需要的循环实现困难，而且表无论是行还是列都是对称的）。所以为了实现该功能，我首先取原有的表格的左上部分单独存为一个如图所示的二维数组。<br><img src="../images/2017-10-6-2.png" alt=""></p>
<p>之后检查第一行各列的数字$n$，若为零，则跳过；若非零，则根据其对应的总角量子数$L$和总自旋角量子数$S$得到其光谱项（若不为1，输出的光谱项后会有类似 <code>&#60;n&#62;</code> 的标记，表明该光谱项的数目为$n$），之后的各行与各列都减去$n$。一行结束后，进入下一行，重复以上的步骤。（没看明白的话，可以按照第一节的例子跟着手算一下）</p>
<p>最终得到的结果是<br><img src="../images/2017-10-6.png" alt=""></p>
<h1 id="further_development">进一步改进</h1>

<p>（很开心，这里提及的功能都已基本实现。当然以后依然会对代码进行完善。）<br>这里倒不是指代码的优化。目前希望是拓展该程序的功能，使之能够处理任意组态，并生成相应的表。</p>
<p>由于快到了回学校的时间，我把写代码的事暂时停下了，该功能要搁置一段时间才能完成。</p>
<p>至于为什么不直接输出所有的光谱项，很简单，我还没想出来怎么实现……</p>
<p>所以目前这都只能算是一个求光谱项的辅助程序。不过我还是挺高兴能写出这么一个玩意的。</p>
<h1 id="final_version">最终版本</h1>

<p>Update(2019/7/16): <del>最终版本之再也不改了</del></p>
<p>进一步学习了Fortran的指针和面向对象编程后，实现了多个相同壳层作为输入的功能。并且把原来的代码几乎重写了一遍。我用gfortran 8编译通过，在gfortran 7上应该也能编译（Intel Visual Fortran肯定也没问题）。代码可以在<a href="https://github.com/St-Maxwell/TermSymbolProgram" target="_blank" rel="noopener">GitHub</a>下载到，没有提供可执行文件（因为之前编译的程序在我现在的电脑上都运行不了，没有安装IVF）。当然如果你不想自己编译的话，我还是可以提供编译好的程序。</p>
<p>以下是运行的例子。<br><img src="../images/2019-07-16_21-37-51.png" alt=""></p>
<h1 id="references">参考文献</h1>

<ol>
<li><cite lang="en">Journal of Chemical Education</cite>, 52(2), <strong>1975</strong>:87-89</li>
<li><cite>大学化学</cite>, 29(2), <strong>2014</strong>:44-46</li>
</ol>]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>光谱项</tag>
      </tags>
  </entry>
  <entry>
    <title>Sob对Exploring Chemistry第三版的批判</title>
    <url>/Sob%E5%AF%B9Exploring-Chemistry%E7%AC%AC%E4%B8%89%E7%89%88%E7%9A%84%E6%89%B9%E5%88%A4/</url>
    <content><![CDATA[<p>一直以来就听说Exploring Chemistry一书的第三版非常不靠谱。刚刚在群里看到Sobereva老师对该书进行了大量的批判（原话：「本来想写个系统性的第三版的大批判，但现在没兴致了，上面只是放出了一部分之前忍不住吐槽的」）。虽然并没有涉及到原书的全部，但个人觉得应该是非常有参考价值的，所以决定收录于此。（应该不涉及侵犯著作权吧？）</p>
<p>以下均为Sob的原文：<br><a id="more"></a></p>
<hr />

<p>光是第一章我就写了一堆吐槽：</p>
<p>维他命D全是废话，看着都烦</p>
<p>计算中的重要经验技巧，如解决不收敛都没提。没有系统性讲讲关键词的使用。空话却很多。</p>
<p>11页对弥散函数的描述有误导性。哪仅限于sp的弥散。超极化率、偶极矩都不提。</p>
<p>通篇把6-311+G(2d,p)当标准基组，害人！<br>第12页的表格，明显可见，对于DFT，6-311G&#42;优化和CBS没什么差异，而书中不提3-zeta的重要，却提加了弥散函数比6-31G&#42;的改进。明显6-31+G&#42;和6-311(d)对于当前问题后者更小，结果更好。<br>也不提CCSD(T)和DFT用的基组要注意差异</p>
<p>一开始就说道密度拟合基组，但这几乎用不着，也没说清楚，干嘛跟初学者提。</p>
<p>14页简直瞎出主意，直接B3LYP优化多好。而且根本不需要弥散函数，还不如把计算量剩下来用混合基组呢。本来算单点也不花多少时间，又是关键，用ONIOM适得其反。或者干脆告诉大家，可以把长链截短。而且表里也没个对比，比如APFD算整个体系当精确结果（或者去掉弥散便宜点，用TZVP这个档），却用ONIOM的当精确值。</p>
<p>23页居然用那么烂的计算级别，还用MP2。还用大基组算频率</p>
<p>55页居然讨论「原子自旋密度」</p>
<p>通篇都在用6-311+G(2d,p)，居然不知道mulliken电荷不兼容弥散函数</p>
<p>p158说g09支持W2，但根本不支持</p>
<p>讲双正交化，还不如用自旋密度容易理解呢。老提到NBO，却不说一下NBO是个啥。</p>
<p>算热力学数据都不提频率校正因子</p>
<p>书中优化总用HF/6-31G*，不知想什么呢，单点用APFD就罢了，优化用HF找审稿人骂呢</p>
<p>76页，居然用CCSD结合那么烂的基组，还算频率，匪夷所思</p>
<p>测试数据老是想往APFD上贴金，老说比更昂贵的MP2好，却不拿对于当前问题好的泛函比，比如M062X</p>
<p>83页的耗时测试很有误导性，线性体系标度低，实际那可能这样。算不同大小的团簇还有得说。</p>
<p>第三章</p>
<p>各种用QST2、QST3，opt=TS却很少说，但实际上QST3根本没用，QST2也明显不如opt=TS好用。</p>
<p>opt=TS居然不用noeigen</p>
<p>103对虚频的处理方式根本不对。&gt;=1虚频时只有约束到了高对称性时扭曲结构通常才有效。虚频&gt;=1也未必是鞍点</p>
<p>102页找到的TS根本就连不通azirine</p>
<p>108页一大堆都不知道想表达什么。关键的，比如热力学量的关系没说，没用的倒说一堆。</p>
<p>113页的比较莫名其妙，什么也没说明，读者只会看了糊涂。直接拿双杂化算一下多好</p>
<p>117页坑爹。没找对过渡态，换初猜、calcfc啊</p>
<p>第四章</p>
<p>APFD/6-311 +G(2d ,p)用B3LYP/6-311+G(3df,2p)的校正因子却不做解释。热力学量至少也应该用ZPE校正因子。</p>
<p>145p，scale根本不影响输出的频率，居然说影响</p>
<p>p154，非要用APFD结合大基组，结果明显没B3LYP/6-31G*与实验相符更好。费力不讨好</p>
<p>p156都没说清楚绝热和垂直IP/EA的区别。</p>
<p>p169，对问题有点回避，对于C7，不考虑权重平均结果反倒好。而且考虑构象平均只考虑了C1。明显是个不成功的例子。这种体系用热力学组合方法多好。</p>
<p>p172 想不出丙酮有什么难优化的。增加积分格点纯粹扯淡。</p>
<p>p189，莫名其妙，明明众所周知B3LYP/6-31G*又快又特别理想，却不用</p>
<p>超极化率计算烂成一锅粥。符号不对。数据混乱，基组太烂</p>
<p>p194 用int=ultrafine纯属胡来，其实CPHF=grid=fine才是关键</p>
<p>p196 BD用6-31G*算单点，APFD用6-311+G(2d,p)优化，简直脑子进水了…</p>
<p>&nbsp;</p>
]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>计算化学</tag>
      </tags>
  </entry>
  <entry>
    <title>氢原子径向波函数数值求解</title>
    <url>/%E6%B0%A2%E5%8E%9F%E5%AD%90%E5%BE%84%E5%90%91%E6%B3%A2%E5%87%BD%E6%95%B0%E6%95%B0%E5%80%BC%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<p>在此之前，我已经写了一段数值求解一维量子谐振子波函数的Python代码。建议先从该帖子开始阅读（<a href="https://www.kechuang.org/t/81454" target="_blank" rel="noopener">Numerov方法数值求解一维量子谐振子波函数</a>），涉及到的Numerov方法的原理就不再重复了。<br><a id="more"></a><br>首先写出径向部分的Schroedinger方程：</p>
<script type="math/tex; mode=display">-\frac{\hbar^2}{2m} \left( R^{\prime\prime} + \frac{2}{r} R^\prime \right)+\frac{l(l+1)\hbar^2}{2mr^2} R+V(r)R=ER</script><p>由于Numerov方法处理的是形如$\psi^{\prime\prime}=G(r)\psi(r)$的微分方程，但上式中存在$R^\prime$项，所以需要消掉。</p>
<p>令$F(r)=rR(r)$，所以：</p>
<script type="math/tex; mode=display">R(r)=r^{-1}F(r)</script><script type="math/tex; mode=display">R^\prime=-r^{-2}F+r^{-1}F^\prime,\ R^{\prime\prime}=2r^{-3}F-2r^{-2}F^\prime</script><p>代入到径向Schroedinger方程中：</p>
<script type="math/tex; mode=display">-\frac{\hbar^2}{2m} F^{\prime\prime}(r)+ \left[ V(r)+\frac{l(l+1)\hbar^2}{2mr^2} \right]F(r)=EF(r)</script><script type="math/tex; mode=display">F^{\prime\prime}(r)=G(r)F(r),\ G(r)=\frac{m}{\hbar^2} \left(2V-2E \right)+\frac{l(l+1)}{r^2}</script><p>递推关系已得到，现在需要讨论边值条件。由于$r\rightarrow 0$时，$R(r)\sim r^l,\ l=0,1,2,\ldots,n$，因此$F=rR$在$r=0$处必为0。</p>
<p>但是这里有一个小问题，$r=0$时，前式中$G(r)$会遇到除以0的情况。为了避免这一情况，我们以一个非常小的$r$作为近似零点（比如令$r=10^{-15}$）。（但是又会带来另一个问题，对于$l=0$的径向波函数，$R(r)|_{r=0}$本应为一非零正值。但我们用该方法产生的结果是在（近似）零点处，波函数为0。然而目前暂时不知道如何处理）</p>
<p>在使用程序实现之前，还是先完成公式的非量纲化。（具体步骤不写了）</p>
<script type="math/tex; mode=display">V_\text{r} =-\frac{e^2}{4\pi\epsilon_0 r}=-\frac{e^{\prime 2}}{r_\text{r}}</script><script type="math/tex; mode=display">E_\text{r} =\frac{E}{\mu e^{\prime 4} \hbar^{-2}}=-\frac{e^{\prime 2}}{2n^2}</script><p>得到约化的Schroedinger方程和递推项分别为：</p>
<script type="math/tex; mode=display">F^{\prime\prime}_\text{r}=G_\text{r}F_\text{r},\ G_\text{r}=\frac{l(l+1)}{r_\text{r}^2}-\frac{2}{r_\text{r}}-2E_\text{r}</script><p>现在就可以使用程序实现了（和之前那个区别不大）。</p>
<p>写的Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">R=&#123;<span class="string">"r0"</span>:<span class="number">1e-15</span>&#125;</span><br><span class="line">F=&#123;<span class="string">"f0"</span>:<span class="number">0.0</span>&#125;</span><br><span class="line">G=&#123;<span class="string">"g0"</span>:<span class="number">0.0</span>&#125;</span><br><span class="line">nn=<span class="number">0</span></span><br><span class="line"> </span><br><span class="line">l=float(input(<span class="string">"Enter angular quantum number(l&gt;=0):"</span>))</span><br><span class="line">s=float(input(<span class="string">"Enter the increment sr:"</span>))</span><br><span class="line">m=int(input(<span class="string">"Enter the number of intervals m:"</span>))</span><br><span class="line">E=float(input(<span class="string">"Enter the reduced energy Er:"</span>))</span><br><span class="line"> </span><br><span class="line">F[<span class="string">"f1"</span>]=<span class="number">0.0001</span></span><br><span class="line">R[<span class="string">"r1"</span>]=R[<span class="string">"r0"</span>]+s</span><br><span class="line">G[<span class="string">"g0"</span>]=l*(l+<span class="number">1</span>)/(R[<span class="string">"r0"</span>]**<span class="number">2</span>)<span class="number">-2</span>/R[<span class="string">"r0"</span>]<span class="number">-2</span>*E</span><br><span class="line">G[<span class="string">"g1"</span>]=l*(l+<span class="number">1</span>)/(R[<span class="string">"r1"</span>]**<span class="number">2</span>)<span class="number">-2</span>/R[<span class="string">"r1"</span>]<span class="number">-2</span>*E</span><br><span class="line">ss=s*s/<span class="number">12</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">  R[<span class="string">"r%s"</span> % (i+<span class="number">1</span>)]=R[<span class="string">"r%s"</span> % i]+s</span><br><span class="line">  G[<span class="string">"g%s"</span> % (i+<span class="number">1</span>)]=l*(l+<span class="number">1</span>)/(R[<span class="string">"r%s"</span> % (i+<span class="number">1</span>)]**<span class="number">2</span>)<span class="number">-2</span>/R[<span class="string">"r%s"</span> % (i+<span class="number">1</span>)]<span class="number">-2</span>*E</span><br><span class="line">  F[<span class="string">"f%s"</span> % (i+<span class="number">1</span>)]=(-F[<span class="string">"f%s"</span> % (i<span class="number">-1</span>)]+<span class="number">2</span>*F[<span class="string">"f%s"</span> % i]+<span class="number">10</span>*G[<span class="string">"g%s"</span> % i]*F[<span class="string">"f%s"</span> \</span><br><span class="line">   % i]*ss + G[<span class="string">"g%s"</span> % (i<span class="number">-1</span>)]*F[<span class="string">"f%s"</span> % (i<span class="number">-1</span>)]*ss)/(<span class="number">1</span>-G[<span class="string">"g%s"</span> % (i+<span class="number">1</span>)]*ss)</span><br><span class="line">  <span class="keyword">if</span> (F[<span class="string">"f%s"</span> % i]*F[<span class="string">"f%s"</span> % (i+<span class="number">1</span>)]&lt;<span class="number">0</span>):</span><br><span class="line">    nn=nn+<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">"Er="</span>+str(E))</span><br><span class="line">print(<span class="string">"Nodes="</span>+str(nn))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">  print(<span class="string">"%f %f"</span> % (R[<span class="string">"r%s"</span> % i],(F[<span class="string">"f%s"</span> % i]/R[<span class="string">"r%s"</span> % i])))</span><br></pre></td></tr></table></figure>
<p>运行该程序需要我们输入角量子数、间隔长度、间隔数和能量。</p>
<p>例如，我们想绘制4p轨道径向部分波函数的图像。首先估计能量：$E\text{r}=-\frac{1}{2\times 4^2}=-0.03125$。然后由$-0.03125=-\frac{1}{r_\text{r}}$得到$r=32$。稍取更远的点$r=36$来验证波函数在此处是否趋于0。设间隔长度为0.1，间隔数自然为360。得到结果如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Er=<span class="number">-0.03125</span></span><br><span class="line">Nodes=<span class="number">2</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span></span><br><span class="line"><span class="number">0.100000</span> <span class="number">0.001000</span></span><br><span class="line"><span class="number">0.200000</span> <span class="number">0.001811</span></span><br><span class="line"><span class="number">0.300000</span> <span class="number">0.002567</span></span><br><span class="line"><span class="number">0.400000</span> <span class="number">0.003247</span></span><br><span class="line"><span class="number">0.500000</span> <span class="number">0.003852</span></span><br><span class="line"><span class="number">0.600000</span> <span class="number">0.004385</span></span><br><span class="line"><span class="number">0.700000</span> <span class="number">0.004853</span></span><br><span class="line"><span class="number">0.800000</span> <span class="number">0.005258</span></span><br><span class="line"><span class="number">0.900000</span> <span class="number">0.005605</span></span><br><span class="line"><span class="number">1.000000</span> <span class="number">0.005899</span></span><br><span class="line"><span class="number">1.100000</span> <span class="number">0.006143</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>用以上数据绘图，可看到与解析解得到的结果非常接近。（注：程序输出的数值与波函数的表达式算出的结果并不一定相同，这是因为没有对数值计算得到的结果进行归一化，将其乘以适当的系数后与理论值基本一致。）</p>
<p><img src="../images/2017-03-11-Graph.png" alt=""></p>
<p>之前提到了，对于s轨道，该程序有一些缺陷，由下图可以看出：</p>
<p><img src="../images/2017-03-11-Graph1.png" alt=""></p>
<p>当$r=0$时，$R(r)$本不为0，所以上图在零点附近的表现不太正确（后面是比较吻合的）。</p>
]]></content>
      <categories>
        <category>量子化学</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>有感于学院里的伸手党们</title>
    <url>/%E6%9C%89%E6%84%9F%E4%BA%8E%E5%AD%A6%E9%99%A2%E9%87%8C%E7%9A%84%E4%BC%B8%E6%89%8B%E5%85%9A%E4%BB%AC/</url>
    <content><![CDATA[<blockquote>
  没错，我就是想喷部分人。
</blockquote>

<p>如果要我和学院里的部分人相比的话，在很多方面我都不如别人。但在伸手这个问题上，我觉得自己做的算好。与一些人交流（现实或QQ上）后，我觉得有些人似乎完全没有自我解决问题的能力。<br><a id="more"></a><br>至于这些人是具体如何伸手的我不必一一列举。每一件都不能算很大的事。但很多交流（尤其是网络社区）事实上就是被伸手党们毁掉的。</p>
<p>为什么要写这些字呢？因为我今天在年级群里问了一件事。</p>
<p>之前有人在某群里匿名问了个事，我很不客气地回复了。然后这一次，我收到了同样的回复。</p>
<p>然而喷我的同学不知道的是，在我提问之前，我在网上搜索至少半个小时我需要的东西，无论是这位知道还是不知道的途径我都找过了。当然结果是没有找到答案，所以去年级群里问了。</p>
<p>直接引用我的回复让我看出来这位（些）同学根本没有意识到他们的伸手行为的讨厌性。他们以为我之前的回复单纯是为了喷人。哦，面白い。</p>
<p>他们喜欢在QQ群里问一些课本上已经写下答案的问题，他们喜欢问一些老师上传至QQ群中的日程安排。</p>
<p>将来他们还会问他们的师兄师姐无数的问题。Sigh…</p>
<p>不知道这些人的解决问题的能力在哪。</p>
<p>对了，我还想喷一喷在QQ群中使用匿名的人。</p>
<p>我们加入一个群体是为了交流，而且是坦诚的，透明的交流。</p>
<p>使用匿名就是不尊重人。（尤其同时还是伸手的）</p>
<p>所以遇到这种情况，我一般都不会很客气的。</p>
<p>最后送属于这类人的同学一个帖子，如果你们能看到这句话的话。</p>
<p><a href="http://bbs.kechuang.org/t/36782" target="_blank" rel="noopener">科创处理提问帖的参考—杜洋：能者自答</a></p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>你是一个好科学家吗？</title>
    <url>/%E4%BD%A0%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%A7%91%E5%AD%A6%E5%AE%B6%E5%90%97/</url>
    <content><![CDATA[<p>这实际是一个小测试。原测试在<a href="http://www.iop.org/activity/education/index.html" target="_blank" rel="noopener">这里</a>，翻译（略有修改）的版本引用自董永贵的《科研中的读与写》一书。</p>
<p>今天早上没事干又翻出了这本书，觉得问卷蛮有意思的（意味微妙），所以在这里分享一下。我相信可以从中学到些东西的（</p>
<p>（P.S. 为毛Onenote的OCR功能比ABBYY的还强啊……如果下文中有一些错误，那是自动识别的问题）  </p>
<p>准备好纸和笔吧。<br><a id="more"></a></p>
<hr />

<p>1.今夜有月全食。课堂上，老师说月食的时候月亮看起来是红色的，并且可以观测到那些月明时看不到的星星。你被要求观测这次月全食，并写一篇观测报告，以作业形式上交。你借了一架双筒望远镜，但使用效果很不好。既不能看到那些暗淡的星星，月亮看起来也不是红色的。你该怎么办？冲动的回答（）理智的回答（）<br>(A)用绘图、列表形式，准确地介绍你所观测到的现象；<br>(B)介绍你所看到的现象。并在报告中添加从网上找到的图片，解释你从图片中看到的内容；<br>(C)观测一会儿，然后从网上找一篇类似报告，修改后交上去；<br>(D)认为老师的说法错了，放弃。  </p>
<p>2.你生活的附近有一条河，河水中一直有鱼。假定近些天发现水面上漂浮有死鱼。在河的上游有一家化工厂，很多人确信该工厂不定期往河里排放某种化工废水，你很气愤，于是：冲动的回答（）理智的回答（）<br>(A)坚持每天观察记录水的情况，记录下何时、何地看到死鱼的大小、种类及其数量，并尽你所能，记录水质变化的数据；<br>(B)打电话通知环保管理部门，告诉他们你有证据表明该工厂在排放污染废水，希望他们表扬你的正义行动；<br>(C)去找人借仪器，开始监测水质；<br>(D)找真正的环保专家，告诉他们你的发现，并探讨解决方法。</p>
<p>3.上学期你学习了某门专业课，所撰写的期末论文得了高分。你的高中好友在外地一所大学上学，给你发来短信要这篇论文。你很担心他会复制这篇论文作为自己的期末论文，你该怎么做？冲动的回答（）理智的回答（）<br>(A)拒绝；<br>(B)发给他，但要求他不要复制你的论文；<br>(C)不给他，但发给他你所参考的文献；<br>(D)发给他，同时给出建议：如果复制，要修改一些内容。</p>
<p>4.你朋友老家附近曾经有过核实验室。最近有传言地下埋藏有放射性物质。你去朋友家的时候，他的父亲说在当地已经看到了螺旋状生长的植物及白色的蚯蚓。希望你带一些当地的土壤标本到学校，找盖革计数器（一种测量核辐射的仪器）测量一下放射性。你会：冲动的回答（）理智的回答（）<br>(A)带标本到学校，自己设法找仪器测量；<br>(B)告诉你的朋友及其家人，放射性分析需要专家及专门的实验室才能做，建议他们找专业的环保部门解决；<br>(C)建议他们开始挖掘，看到底有没有放射性物质；<br>(D)找当地环保部门，很可能他们已经注意到了这种传言，并开始调查。找到负责人，建议他多跟当地群众交流。</p>
<p>5，昨天你做了一天实验。导师要求你「做张表格，将全部数据记录到表格里面。」不幸的是，你并没有这么做，而是将数据记录到了一张废纸的背面。今天来实验室，你发现那张纸不见了，据实验室师兄说是被当作废纸丢掉了。你该怎么做？冲动的回答（）理智的回答（）<br>(A)冲到实验室外面的垃圾存放处，看能否找到那张纸；<br>(B)将前天的实验数据略做修改，交给导师；<br>(C)找到导师，实话实说；<br>(D)任何事情都不做，直到导师找你要数据时，再想办法。</p>
<p>6.你到外单位做了一个实验，比较不同品种苹果的水分含量。最后整理报告的时候发现缺了一个关键数据:在称苹果切片重量的时候忘记称每个托盘的重量，因此无法知道苹果切片烤干前的确切重量，你会怎么做？冲动的回答（）理智的回答（）<br>(A)估计一个托盘重量，保证处理后的数据与其他人的实验结果接近，写到报告中；<br>(B)接受这个事实，写你能写的内容；<br>(C)向导师坦承错误，看能否与合作单位联系，重新实验；<br>(D)找合作单位帮助你做实验的人，看他能否提供一些虽然不真实，但看起来合理的托盘重量数据，帮你完善报告。</p>
<p>7.假定上述苹果实验是作为某门课程的实验作业做的。有6种苹果需要测量，但你只做了2种。由于烘干过程需要时间很长，有同学建议大家将各自得到的数据汇总，这样每个人都可以有一套完整的数据。你怎么想？冲动的回答（）理智的回答（）<br>(A)好主意，我先把自己的数据共享出来；<br>(B)不太积极。因为大家进度不一致，你认为自己的数据已经足以完成作业了；<br>(C)反对，你不太相信别人的数据。</p>
<p>8．大象会往自己身上洒水。有一种说法是这样可以降温。物理实验课上，要求你研究一下这种说法是否可信。具体实验方案是：用两个盛满温水的塑料杯子模拟「大象」，外侧分别包裹干燥的以及润湿的吸水纸，测量记录温度下降过程的温度变化情况。不幸的是，实验快结束的时候，不小心碰歪了包裹干燥吸水纸的杯子。现在两只“大象”都湿了。重新做实验，时间已经来不及了。你怎么办？冲动的回答（）理智的回答（）<br>(A)结束实验，用已有数据得到结论；<br>(B)跟老师解释，争取得到许可，重新安排时间实验；<br>(C)用干燥的纸换下打湿的纸，继续实验；<br>(D)由于杯子依然几乎是满的，继续实验，记录下全部实验现象，整理报告交上去。</p>
<p>9.测量橡胶条拉伸长度与拉伸力之间的关系，得到的数据在图上大部分呈线性，只有一个点不是，你怎么处理？冲动的回答（）理智的回答（）<br>(A)去掉该数据，不画在图上；<br>(B)回忆整个实验过程，记得该实验点的出现是因为当时有点打滑现象。画出该数据点，并解释该数据点为什么是不可信的；<br>(C)重复测量该实验点；<br>(D)想一个合理的数据，画在图中。</p>
<p>10.某课程教师设计了一组包含多种不同实验的动手实验。大家都在实验室中进行实验，教师不在场指导。你发现某个实验非常难做，有个同学恰好非常喜欢该实验，承诺可以进行多次实验，并将结果与大家分享。而你在另外一个实验中，也有这种优势。于是大家开始合作，你将怎样写实验报告？冲动的回答（）理智的回答（）<br>(A)解释你们是组成了实验小组得到的实验数据，对每个实验都给出实验结果，并分别注明实验结果的具体操作者；<br>(B)对每个实验都给出实验结果，表明全部实验数据都是你自己得到的；<br>(C)只写自己所做的实验结果。</p>
<hr />

<p>为了不影响读者回答问题的兴趣，下面的内容按照倒序给出。</p>
<p>1.得分结果分析<br>（1)低于零分<br>不仅不是个好的科学家，甚至某种意义上说未必是个有良好品质的人。习惯于欺骗与说谎，对朋友的安全是个威胁。<br>（2）0-8分<br>可能需要思考一下诚信的问题了。科学是解释真实发生的事情，而不是记录自己认为应该发生的事情。拼凑一个结果，看起来似乎是科研的捷径，但如果每个人都这么做，我们现在可能还在相信太阳是绕着地球转的。<br>（3）8-14分<br>具备成为好科学家的许多品质。需要提高的是这样一种意识：一个好的科学家必须与他人合作，科学上的成功往往是见解分享的结果。<br>（4）14分以上<br>具备成为好科学家的几乎全部品质。诚实、守信、有合作精神、工作严谨，学习与工作中都会受到他人的欢迎与尊重。值得注意的是「冲动的回答」与「理智的回答」两者的区别。如前所述，「冲动的回答」是一种直觉，一种不考虑社会道德层面以及许多其他人为因素的回答。「理智的回答」则是考虑了许多社会现实因素后，可以展示给他人看的回答。所以后者的得分高于前者，应该是一种正常的现象。毕竟心里还是知道正确做法的，需要完善的只是将这种认识更多地落实在实际行动中。反之，如果后者的得分比前者还要低，就要谨慎了。很可能有些概念在潜意识里就是错的，需要有意识地更正。</p>
<p>需要说明的是，上述文字基本上是原文内容翻译过来的，有些可能未必适合我国的情况，仅建议作为一种娱乐性质的参考。有些人可能天生就很善于填写这种答卷，参考价值就会更小一些。</p>
<p>下面针对题目给出的分析，才是本书希望告诉读者的内容。</p>
<p>2.题目及答案分斩</p>
<p>问题1.月全食观测。答案选项中，C属于造假，D则缺乏探索精神，所以都是不可取的，均为-2分。需要认真区别的是A与B。科学研究中的观测结果容易受到很多意料之外因素的影响，这些因素常常是随机的。参考他人的观测结果，相当于组成了一个虚拟的观测团队，得到的结果就更具有科学性。所以，A虽然是观测结果的客观描述，但还不是最好的，得分为2。最好的方法是B，得分为3。如果你的选择是A，建议重新审视以下自己对参考文献重要性的看法。</p>
<p>问题2．河水污染。考察的是对待成果发布以及应对媒体的态度。尽心尽力地做高水平的研究工作，应该是科学研究的基本准则。在确认事实之前就公布结论，是一种很不可取的态度，所以B的得分为-2。A与C是比较容易困惑的选项。水质变化当然会导致死鱼，但死鱼现象未必就是水质污染导致，所以这种先入为主的研究方法容易出现偏差，C选项得分为0。相比之下，A选项考虑因素更多，得分为1。寻找该领域的专家探讨，可让后续的研究工作更专业，也少走许多弯路，所以最佳的选项为D，为2分。</p>
<p>问题3，论文复制。估计是很容易发生的现象，答案选择不仅涉及学术作假的问题，还要考虑相互交流、相互帮助的因素。D一定是错的，得分为-2。抄袭所伤害的不仅是抄袭者，对协助抄袭者也会是一种严重的伤害。科学研究有社会性，帮助他人才能期望得到他人的帮助。所以直接拒绝也不是很好的选项，A的得分为0。B选项存在一定的风险，但如果是可信的朋友，应该是会考虑到你的利益的。B选项得分为1。最佳的答案是既能为朋友提供帮助，又不至于伤害到自己，所以C选项最佳，得分为2。</p>
<p>问题4，核辐射。乍看起来与问题2的内容类似，最大的区别在于核辐射领域的特殊性与专业性。有一种说法可以很好地说明科学研究的专业性：技术专家是对越来越少的事情知道的越来越多，哲学家则是对越来越多的事情知道的越来越少。一个人的精力有限，不可能在很多专业领域都成为专家。放射性化学分析是非常专业的事情，在具备足够的专业研究经验之前，贸然从事自己所不熟悉的研究是危险的。所以A选项看起来合理，其实并不好，得分为-1。相比之下，B与D是比较好的选项，得分均为1。C则是一种完全不负责任的做法，得分为-2。</p>
<p>问题5，丢失的记录。问题所描述的现象本身就是应该受到批评的。A选项或许可以弥补过失，得分为0。C大概是唯一可行的办法，得分为2。B与D当然是错的，得分均为-2。</p>
<p>问题6，苹果称重。这也是一种比较容易发生的现象。在实验之前做好功课，尤其是在实验笔记上给出实验流程、数据记录格式等内容，可有效避免这种尴尬情况的发生。由于托盘重量直接影响到了结果的准确性，所以最佳的选择是C，得分为1。B选项是不得已而为之，毕竟得到的数据还是有些参考价值的，得分为0。选项A与D均为虚假数据，得分均为-2。</p>
<p>问题7，数据分享。选项B不仅反映合作态度的缺失，只做了两种就认为自己的数据已经足以完成作业了，也说明对于科学研究的兴趣不高，得分为-1。由于还需要考虑到同学间的成绩竞争因素，A与C选项的区别并不是很严格。相比之下，A要更好一些，得分为1。C选项的得分为0。</p>
<p>问题8，大象降温实验。这个问题所考察的是应对实验过程出现意外状况的态度。意外虽然是一种不理想的、偏离实验初衷的现象，但有时也是发现新现象、新原理的机遇。选项C所得到的数据一定是虚假的，得分为-2。选项A是一种被动、缺乏坚持精神的消极态度，得分为-1。难以给出判断的是B与D。实验目的是明确的，实验过程也是预先安排好的，选择B可以保证实验计划的稳定性，应该是一种正常的选择，得分为1。最佳的选项是D，得分为2。科研与那种有“标准答案”的学习过程不一样，养成“非理想情况也有学术价值”的理念，意外情况的发生很可能会转化为新发现的起点。</p>
<p>问题9。拉伸力实验。这个问题与问题8有些类似。问题8考察的是对实验过程意外的态度，这个问题考察的是对实验数据意外的态度。A与D当然是不对的，属于虚假结果。值得注意的是，这种情况确实是经常发生的。多年的课程学习，尤其是课程学习过程中的考试压力，很容易养成「如果我的结果与书上说的不一致，那就是我错了」的观念。出现异常数据，未必就能说明实验所依据的原理是错的，但既然能够出现，就一定是有道理的。实际上，教科书中给出的理论至少绝大部分是正确的，挑战这些理论的正确性很可能是毫无价值的。不过，这些理论往往是建立在理想条件基础之上的。物理实验装置的非理想性、实验材料的非理想性，很可能导致非理想数据的出现。研究这些非理想数据产生的原因，会成为有价值研究工作的起点。C选项对于异常数据点进行深入实验研究的做法最为可取，得分为2。B选项至少分析了导致异常数据的可能原因，得分为1。</p>
<p>问题10.实验的合作。选项B不仅是虚假的，还会让你失去他人的信任，影响将来的发展，得分为-2。选项A与C的选择与实验课程的要求有关。如果不考虑课程教师的要求，A选项是最值得鼓励的，得分为2，这也是在科研过程中最应该采取的态度。C选项略差一些，得分为1。</p>
<p>3.参考答案</p>
<p>问题1，月全食观测。<br>A（2）；  B（3）；  C（-2）；  D（-2）<br>问题2，河水污染。<br>A（1）；  B（-2）；  C（0）；  D（2）<br>问题3，论文复制。<br>A（0）；  B（1）；  C（2）；  D（-2）<br>问题4，核辐射。<br>A（-1）；  B（1）；  C（-2）；  D（1）<br>问题5，丢失的记录。<br>A（0）；  B（-2）；  C（2）；  D（-2）<br>问题6，苹果称重。<br>A（-2）；  B（0）；  C（1）；  D（-2）<br>问题7，数据分享。<br>A（1）；  B（-1）；  C（0）<br>问题8，大象降温实验。<br>A（-1）；  B（1）；  C（-2）；  D（2）<br>问题9，拉伸力实验。<br>A（-2）；  B（1）；  C（2）；  D（-2）<br>问题10，实验的合作。<br>A（2）；  B（-2）；  C（1）</p>
]]></content>
  </entry>
  <entry>
    <title>为什么我不着急进实验室</title>
    <url>/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E7%9D%80%E6%80%A5%E8%BF%9B%E5%AE%9E%E9%AA%8C%E5%AE%A4/</url>
    <content><![CDATA[<p>首先引用一下 @exoto在知乎的回答吧。</p>
<blockquote>作者：王吧
链接：https://www.zhihu.com/question/50467496/answer/121133401
来源：知乎
著作权归作者所有，转载请联系作者获得授权。
<a id="more"></a>
化学科研忌广而浅。
如果想要做科学家，逻辑要严谨，思维要紧密，结合对现代学科发展的广而深的理解，具有对问题的洞察力才是做成功科研的关键能力。这些能力需要在phD阶段进行培养并非本科阶段。所以不要想还没学会走就跑，不现实---你必须要接受这个问题。
本科阶段的科研成就实际上取决于你师兄和老板和项目，这是因为一般本科水平的人，不管读多少（研究生）教材，会多少反应操作，读过多少文献，而并不具有独立思考项目的能力。你在这个阶段做的是“手”而不是“脑”。
本科阶段能做什么呢？
1，熟读高等教材，比如想做有机类科研，请熟读carey高等有机化学，对你所参与的化学科研方向首先具备广但是并不深的认识。。我相信在这个阶段你已经熟悉科研所需英语了，并且对本专业课程相对认真的完成了，具有化学学科一定的理解。这是学会爬的一步
2，在对专业科研具有广而浅的理解之后，你需要实验来把对学科的理论了解转化成实际了解，这是纸上谈兵到小试牛刀的转化过程。这需要你去参与到科研当中去。不要想着我要本科发个大paper，一定要静下心来磨练自己的实验技能，没有“手”，日后“脑”多好也无法完成任务。我觉得这个阶段虽然会可能有文章，但是并不是你original的，所以有成果也不要骄傲。好好听老板和师兄的教诲。在初步科研期间，你会大量接触现代文献，从而对科研领域具有一个广但仍然不深的理解，这是理论层面上你从书本的纸上谈兵逐渐到实际科研里小试牛刀的一步。举例子来说，如果做不对称合成，如果你具有阶段2的层次，你会明确意识到你的第一步不是各种找催化剂，怎么应用到（全）合成里。而是，近到怎么备料，远一点到怎么做HPLC消旋标准样品来找到HPLC拆分条件。怎么做备料（底物合成）才是你第一个需要思考的问题。拿到ee这种结果是你最后的时候需要思考的问题。这期间你还得知道怎么纯化产物，怎么表征产品（需要熟知谱学），给出可以重复的分离产率然后才是走到HPLC拆分确定ee这一步的。
如果你只具备阶段1的能力（纸上谈兵），显然你是无法看见这一步的。这一切是学会走的一步。

3，初步参与科研一段时间后，你技能熟练，阅读过一定现代文献，参与过组会报告，文献报告等。具有一定的报告和学习能力之后，这个时候你可以走到真正的科研里---也即是写研究提议，然后开展原创性工作--这才是科研，是基于前人成果之上（深刻见解），根据严谨的逻辑分析给出新的科研提议。并且深刻知道具体操作上怎么实施。
阶段3要求在2的基础之上，具有训练有素的逻辑思维，需要强大的写作能力，报告能力，论证能力。这是极少本科生能做到的，这是phd期间进行培养的，甚至到PI阶段有些人还在学习提升这些能力。科研就是你对一个新提出的问题要给出合理严谨的实验方案来找出答案，这个实验怎么设计？举个例子Clement最近报道了一个pd催化的烯烃迁移反应，可以把远程烯烃迁移到醇那里从而产生热力学温度的酮/醛，你首先思考的问题是这个反应的机理？他们的假设是1，分子内Pd-H沿着碳链行走（加成双键，还原消除，烯烃-Pd-H异构化,pi插入Pd-H键。。。）2，分子间过程，也即pd催化下，还原了底物，并把所得电子将醇氧化。
怎么区分和证实这个猜想？怎么设计实验？我现在在这里列举clement设计的一个支持假设1的实验：他们设计了一个手性底物2m，如果pd-H爬过C链，那么这个手性中心的对映纯度至少会被侵蚀掉一部分，而实验结果是：
手性底物2m的手性甲基C消旋了，而分子间机理是无法导致这个结果的，这个实验设计巧妙得支持了Pd-H沿着碳链迁移的机理1。

(假装有图)

但是纸面之外，不要忘记2m的制备是一个问题吧？他的不对称合成如何实现（看你文献survey能力了），他的消旋标准样品的制备？（文献survey能力）纯化方法？他的HPLC拆分条件（怎么确定ee？动手能力）等等。。。。纸面上一个ee=97%也是凝结了很多心血的。
这是层面2里要达到的境界。
等你达到境界3的时候才可以说-我会科研了，我可以独立提出观点/假设，并针对我的假设给出合理的，严谨的实验设计去验证假设的合理性，最后如何通过所学的新的知识去扩展应用。这才是科研。

很多人觉得化学类科研是玄学，这是不对的，这种观点是极其肤浅的，很多论文的内在远非纸面几个分子式能体现的。科学是人类之大智的体现，其聪明之处是需要切身投入，深入学习才能理解的。就像我之前说的，一个ee=97%也是需要很多心血才能拿到的。
很多现代体系，比如sharpless不对称双羟基化反应，为什么用那个试剂，那个试剂在那个含量，他的操作是那样的（比如需要剧烈搅拌）。这背后都是科学，是根据现象进行假设（比如加入硫酰胺之后加速了反应的现象），并通过设计实验进行论证（思考下，你如果是sharpless，怎么去验证这个添加剂在机理里的角色？）之后，并结合不断的优化的结果。（这其中精彩的还有sharpless里的3+2还是2+2机理的争论问题。）
这是需要多年逻辑思维训练，实验技能训练才能获得的。绝不是单单的“看过carey”就能解决的这么简单的事情。

回到原题上：怎么做？本科只能打好基础，你现在的层次就是在海拔100米高度（没竞赛的高考生大约50米？），你在问的问题是我怎么爬到近9000米高的珠穆朗玛山顶。我能劝你做的只有从现在开始做好1和2步，先爬个2000米到山低的驻扎营，且认识到山顶离现在的你还有近9000米远的事实。只有知道山外有山才能踏实起来打好基础，只有认识到不足才能提升</blockquote>

<hr />

<p>今天在知乎上看到了这个提问，觉得挺有意义的，所以擅自转来了。</p>
<p>事实上，我一直就在考虑这个问题。</p>
<p>当然，进实验室做科研是必须的，但是在毫无任何底子的前提下进实验室是低效的。</p>
<p>我很清楚自己的水平，所以我选择多读一些课本。</p>
<p>我认识的一些大神，对于他们而言，他们已有足够的基础去了解、参与科研。</p>
<p>但我也认识一些人，他们连有机也没有学，便跑去了有机化学的课题组。</p>
<p>我不知道他们去干嘛。</p>
<p>好吧，也许他们确实会学习到过柱子之类的技能。</p>
<p>实验毕竟是科研的重要一环。</p>
<p>但是，我们连基础的有机实验也没做过啊。</p>
<p>对于科研，要有热心；他们有。</p>
<p>但是科研不仅仅需要热心。</p>
<p>我没有资格对别人品头论足，但总之这是我的态度。</p>
<p>无所谓吧，当他们在路上奔波时，我不如多看几本书。</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
</search>
